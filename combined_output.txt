// ----- client.py -----
import login_frame
import wx
import socket
import cryptManager
import sys
import networkManager
import base64
from wx import adv


def handle_key_exchange(sock: socket.socket):
    # recv rsa
    # send aes
    net = networkManager.NetworkManager(sock, cryptManager.CryptManager(rsa_key=2), {})
    net.crypt_manager.generate_aes_key()
    rsa_pub_msg = net.recv_message_plain().decode()
    rsa_pub_key = base64.b64decode(net.get_message_params(rsa_pub_msg)[0])
    print("THE RSA PUB \n", rsa_pub_key)
    print("The aes key ive chosen: ", net.crypt_manager.aes_key)
    aes_encrypted = net.crypt_manager.encrypt_rsa(
        base64.b64encode(net.crypt_manager.aes_key), rsa_pub_key
    )
    net.send_message_plain(
        net.build_message(
            "KEY", [base64.b64encode(aes_encrypted).decode()], do_size=True
        )
    )
    return net


def main(sock: socket.socket):
    net = handle_key_exchange(sock)
    print("Finished key exchange")
    app = wx.App()
    login_fram = login_frame.LoginFrame(net)
    login_fram.Show()
    # frame = main_frame.MainFrame(net,username)
    # frame.Show()
    app.MainLoop()
    # pass
    net.send_message(net.build_message("EXIT", []))
    net.sock.close()
    print("Exiting")


if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else "127.0.0.1"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 12345
    sock = socket.socket()
    try:
        sock.connect((host, port))
        print("Connected to server")
    except Exception as e:
        print("Connection failed")
        raise e
    main(sock)


// ----- cryptManager.py -----
import base64
import unittest
from termcolor import colored
from Crypto.PublicKey import RSA
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad
import hashlib
from typing import Tuple, Optional
import pytest
PRINT_PLAIN = False
# import logging


def log_success(message):
    print(f"\033[32m{message}\033[0m")  # Green for success


def log_failure(message):
    print(f"\033[31m{message}\033[0m")  # Red for failure


class CryptManager:
    def __init__(self, rsa_key=None):
        self.rsa_key = RSA.generate(2048) if rsa_key is None else rsa_key
        self.rsa_cipher = PKCS1_OAEP.new(self.rsa_key)
        self.aes_key: Optional[bytes] = None

    def hash_pass(self, password: str, salt: bytes, paper: bytes) -> str:
        # encrypt using Sha256 and hashlib
        return hashlib.sha256(password.encode() + salt + paper).hexdigest()

    def encrypt_data(self, data: bytes) -> Tuple[bytes, bytes]:
        # encrypt using AES Cbc
        if self.aes_key is None:
            raise ValueError("AES Key is not set.")
        iv = get_random_bytes(16)
        aes_cipher = AES.new(self.aes_key, AES.MODE_CBC, iv)
        # print("IV: ", iv, "KEY: ", self.aes_key, "DATA: ", data)
        if PRINT_PLAIN:
            print("ENC(rypting)>>>", data)
        return aes_cipher.encrypt(pad(data, 16)), iv

    def generate_aes_key(self):
        self.aes_key = get_random_bytes(16)

    def decrypt_data(self, data: bytes, iv: bytes) -> bytes:
        if self.aes_key is None:
            raise ValueError("AES Key is not set.")
        # print("IV: ", iv, "KEY: ", self.aes_key, "DATA: ", data)
        if PRINT_PLAIN:
            print("DEC>>>", data)
        aes_cipher = AES.new(self.aes_key, AES.MODE_CBC, iv)
        return unpad(aes_cipher.decrypt(data), 16)

    def encrypt_rsa(self, data: bytes, public_key: bytes) -> bytes:
        """
        Encrypts data using the given RSA public key.
        """
        rsa_key = RSA.import_key(public_key)
        print(rsa_key.export_key() == public_key)
        rsa_ciph = PKCS1_OAEP.new(rsa_key)  # Public key for encryption
        return rsa_ciph.encrypt(data)

    def decrypt_rsa(self, data: bytes) -> bytes:
        """
        Decrypts data using the RSA private key.
        """
        return self.rsa_cipher.decrypt(data)

    def generate_random_bytes(self, length: int) -> bytes:
        return get_random_bytes(length)

    def check_hash(
        self, password: str, hashed_password: bytes, salt: bytes, paper: bytes
    ) -> bool:
        return hashed_password == self.hash_pass(password, salt, paper)

    def get_public_key(self) -> str:
        return base64.b64encode(self.rsa_key.publickey().export_key()).decode()

@pytest.fixture
def crypt_manager():
    """Fixture to create a fresh CryptManager instance for each test."""
    return CryptManager()


@pytest.fixture
def sample_data():
    """Fixture to provide common test data."""
    return {
        "password": "password123",
        "salt": get_random_bytes(16),
        "paper": get_random_bytes(16),
        "data": b"Secret data"
    }


class TestHashFunctions:
    """Tests for password hashing functions."""

    def test_hash_pass_consistent(self, crypt_manager, sample_data):
        """Test that hash_pass produces consistent results with same inputs."""
        hashed1 = crypt_manager.hash_pass(
            sample_data["password"], 
            sample_data["salt"], 
            sample_data["paper"]
        )
        
        hashed2 = crypt_manager.hash_pass(
            sample_data["password"], 
            sample_data["salt"], 
            sample_data["paper"]
        )
        
        assert hashed1 == hashed2, "Hash function should be deterministic"

    def test_hash_pass_different_with_different_inputs(self, crypt_manager, sample_data):
        """Test that hash_pass produces different results with different inputs."""
        hashed1 = crypt_manager.hash_pass(
            sample_data["password"], 
            sample_data["salt"], 
            sample_data["paper"]
        )
        
        # Different password
        hashed2 = crypt_manager.hash_pass(
            "different_password", 
            sample_data["salt"], 
            sample_data["paper"]
        )
        
        assert hashed1 != hashed2, "Different passwords should produce different hashes"

        # Different salt
        different_salt = get_random_bytes(16)
        hashed3 = crypt_manager.hash_pass(
            sample_data["password"], 
            different_salt, 
            sample_data["paper"]
        )
        
        assert hashed1 != hashed3, "Different salts should produce different hashes"

        # Different paper
        different_paper = get_random_bytes(16)
        hashed4 = crypt_manager.hash_pass(
            sample_data["password"], 
            sample_data["salt"], 
            different_paper
        )
        
        assert hashed1 != hashed4, "Different papers should produce different hashes"

    def test_check_hash_valid(self, crypt_manager, sample_data):
        """Test that check_hash validates correct passwords."""
        hashed = crypt_manager.hash_pass(
            sample_data["password"], 
            sample_data["salt"], 
            sample_data["paper"]
        )
        
        assert crypt_manager.check_hash(
            sample_data["password"], 
            hashed, 
            sample_data["salt"], 
            sample_data["paper"]
        ), "check_hash should return True for valid password"

    def test_check_hash_invalid(self, crypt_manager, sample_data):
        """Test that check_hash rejects wrong passwords."""
        hashed = crypt_manager.hash_pass(
            sample_data["password"], 
            sample_data["salt"], 
            sample_data["paper"]
        )
        
        assert not crypt_manager.check_hash(
            "wrong_password", 
            hashed, 
            sample_data["salt"], 
            sample_data["paper"]
        ), "check_hash should return False for invalid password"


class TestAESEncryption:
    """Tests for AES encryption functions."""

    def test_generate_aes_key(self, crypt_manager):
        """Test that generate_aes_key creates a valid key."""
        crypt_manager.generate_aes_key()
        assert crypt_manager.aes_key is not None, "AES key should be set"
        assert len(crypt_manager.aes_key) == 16, "AES key should be 16 bytes"

    def test_encrypt_decrypt_data(self, crypt_manager, sample_data):
        """Test AES encryption and decryption cycle."""
        crypt_manager.generate_aes_key()
        encrypted_data, iv = crypt_manager.encrypt_data(sample_data["data"])
        
        # Verify encrypted data is different from original
        assert encrypted_data != sample_data["data"], "Encrypted data should differ from original"
        
        # Verify decryption returns original data
        decrypted_data = crypt_manager.decrypt_data(encrypted_data, iv)
        assert decrypted_data == sample_data["data"], "Decrypted data should match original"

    def test_encrypt_data_no_key(self, crypt_manager, sample_data):
        """Test that encrypt_data raises ValueError when AES key is not set."""
        with pytest.raises(ValueError, match="AES Key is not set."):
            crypt_manager.encrypt_data(sample_data["data"])

    def test_decrypt_data_no_key(self, crypt_manager, sample_data):
        """Test that decrypt_data raises ValueError when AES key is not set."""
        iv = get_random_bytes(16)
        with pytest.raises(ValueError, match="AES Key is not set."):
            crypt_manager.decrypt_data(sample_data["data"], iv)


class TestRSAEncryption:
    """Tests for RSA encryption functions."""

    def test_rsa_encryption_decryption(self, crypt_manager, sample_data):
        """Test RSA encryption and decryption cycle."""
        public_key = crypt_manager.rsa_key.publickey().export_key()
        encrypted_data = crypt_manager.encrypt_rsa(sample_data["data"], public_key)
        
        # Verify encrypted data is different from original
        assert encrypted_data != sample_data["data"], "RSA encrypted data should differ from original"
        
        # Verify decryption returns original data
        decrypted_data = crypt_manager.decrypt_rsa(encrypted_data)
        assert decrypted_data == sample_data["data"], "RSA decrypted data should match original"

    def test_encrypt_rsa_invalid_key(self, crypt_manager, sample_data):
        """Test that encrypt_rsa raises an error with invalid key."""
        invalid_key = b"invalid_key_data"
        with pytest.raises(ValueError):
            crypt_manager.encrypt_rsa(sample_data["data"], invalid_key)

    def test_get_public_key(self, crypt_manager):
        """Test that get_public_key returns a valid base64 encoded key."""
        public_key = crypt_manager.get_public_key()
        
        # Verify it's a non-empty string
        assert isinstance(public_key, str), "Public key should be a string"
        assert public_key, "Public key should not be empty"
        
        # Verify it can be decoded as base64
        try:
            decoded = base64.b64decode(public_key)
            assert decoded, "Decoded public key should not be empty"
        except Exception as e:
            pytest.fail(f"Failed to decode public key as base64: {e}")


class TestUtilityFunctions:
    """Tests for utility functions."""

    def test_generate_random_bytes(self, crypt_manager):
        """Test generate_random_bytes produces correct length output."""
        lengths = [8, 16, 32, 64]
        
        for length in lengths:
            random_bytes = crypt_manager.generate_random_bytes(length)
            assert len(random_bytes) == length, f"Random bytes should be {length} bytes long"
            
            # Generate another set and verify they're different (extremely unlikely to be the same)
            another_random = crypt_manager.generate_random_bytes(length)
            assert random_bytes != another_random, "Random bytes should be different on each call"



// ----- dbManager.py -----
from typing import Any
from dotenv import load_dotenv
import os
from typing import Optional
import logging
import unittest

# import logging
from typing import List, Dict
import shutil

# from datetime import datetime
from mysql.connector import Error

# from unittest.mock import patch, MagicMock
# import pytest
import mysql.connector
from mysql.connector import MySQLConnection
import datetime
from dataclasses import dataclass, field
from typing import Tuple

# import hashlib
import uuid
import base64
from mysql.connector.pooling import PooledMySQLConnection
import re
import pickle


@dataclass
class User:
    id: int
    username: str
    hashedPass: str
    salt: str
    isPublic: bool
    createTime: datetime.datetime = None

    def __post_init__(self):
        if self.createTime is None:
            self.createTime = datetime.datetime.now()


# {"username": "u1", "position": 1, "content": "hello", "type": "insert"}
@dataclass
class Summary:
    id: int
    ownerId: int
    shareLink: str
    path_to_summary: str
    font: str
    createTime: Optional[datetime.datetime] = None
    updateTime: Optional[datetime.datetime] = None
    content: str = ""


@dataclass(eq=True, frozen=False)
class Node:
    id: int
    name: str
    type: str
    children: List["Node"] = field(default_factory=list, compare=False, hash=False)

    def __hash__(self):
        return hash((self.id, self.name, self.type))


# @dataclass
# class Event:
#     id: int
#     userId: int
#     event_title: str
#     event_date: datetime
#     createTime: Optional[datetime] = None
#     updateTime: Optional[datetime] = None
from typing import Any, Dict, List, Optional, Tuple, Union
import mysql.connector
from mysql.connector.pooling import PooledMySQLConnection
from mysql.connector import MySQLConnection
import sqlite3
import re


class DBConnection:
    """Abstract database connection class to support both MySQL and SQLite."""
    
    class ConnectionProxy:
        """Proxy class for the connection object to add methods."""
        def __init__(self, parent):
            self._parent = parent
            self._connection = None
            
        def __getattr__(self, name):
            """Forward attribute access to the actual connection."""
            if self._connection is None:
                raise AttributeError("Connection not established")
            return getattr(self._connection, name)
            
        def commit(self):
            """Commit the current transaction."""
            if self._connection is None:
                return False
                
            try:
                self._connection.commit()
                return True
            except Exception as e:
                print(f"Error committing transaction: {e}")
                return False
                
        def close(self):
            """Close the connection."""
            if self._connection is None:
                return
                
            try:
                self._connection.close()
                self._connection = None
                if self._parent.cursor._cursor:
                    self._parent.cursor._cursor = None
            except Exception as e:
                print(f"Error closing connection: {e}")
                
    class CursorProxy:
        """Proxy class for the cursor object to add methods."""
        def __init__(self, parent):
            self._parent = parent
            self._cursor = None
            
        def __getattr__(self, name):
            """Forward attribute access to the actual cursor."""
            if self._cursor is None:
                raise AttributeError("Cursor not established")
            return getattr(self._cursor, name)
            
        def execute(self, query, params=None):
            """Execute a query with parameters."""
            if self._cursor is None:
                return False
                
            try:
                # Transform query if needed
                print("Executing on type: ", self._parent.db_type)
                print(query)
                print("Params: ", params)
                if self._parent.db_type == 'sqlite' and params:
                    print("ITS SQLITE")
                    query, params = self._parent._transform_query_for_sqlite(query, params)
                
                # Execute the query
                if params:
                    self._cursor.execute(query, params)
                else:
                    self._cursor.execute(query)
                    
                return True
            except Exception as e:
                print(f"Error executing query: {e}")
                print(f"Query: {query}")
                print(f"Params: {params}")
                return False
                
        def fetchone(self):
            """Fetch one result."""
            if self._cursor is None:
                return None
                
            try:
                result = self._cursor.fetchone()
                return result
            except Exception as e:
                print(f"Error fetching one result: {e}")
                return None
                
        def fetchall(self):
            """Fetch all results."""
            if self._cursor is None:
                return []
                
            try:
                results = self._cursor.fetchall()
                return results
            except Exception as e:
                print(f"Error fetching all results: {e}")
                return []
                
        def close(self):
            """Close the cursor."""
            if self._cursor is None:
                return
                
            try:
                self._cursor.close()
                self._cursor = None
            except Exception as e:
                print(f"Error closing cursor: {e}")
                
        @property
        def rowcount(self):
            """Get the number of affected rows."""
            if self._cursor is None:
                return 0
            return self._cursor.rowcount
    
    def __init__(self):
        self.connection_proxy = self.ConnectionProxy(self)
        self.cursor_proxy = self.CursorProxy(self)
        self.db_type = None
    
    @property
    def connection(self):
        return self.connection_proxy
        
    @property
    def cursor(self):
        return self.cursor_proxy
    
    def connect(self, db_config: Dict[str, Any]) -> bool:
        """Connect to database based on the config provided."""
        if 'db_type' not in db_config:
            # raise ValueError("db_type must be specified in db_config")
            db_config['db_type'] = 'mysql'
        self.db_type = db_config['db_type']
        
        try:
            if self.db_type == 'mysql':
                # Remove the db_type key from the config
                mysql_config = {k: v for k, v in db_config.items() if k != 'db_type'}
                self.connection_proxy._connection = mysql.connector.connect(**mysql_config)
                self.cursor_proxy._cursor = self.connection_proxy._connection.cursor(dictionary=True, buffered=True)
                return True
            elif self.db_type == 'sqlite':
                self.connection_proxy._connection = sqlite3.connect(db_config['database'],detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES) 
                # Enable row factory to mimic dictionary cursor behavior
                self.connection_proxy._connection.row_factory = self._dict_factory
                self.cursor_proxy._cursor = self.connection_proxy._connection.cursor()
                return True
            else:
                raise ValueError(f"Unsupported database type: {self.db_type}")
        except Exception as e:
            print(f"Error connecting to {self.db_type} database: {e}")
            return False
    
    def _dict_factory(self, cursor, row):
        """Convert SQLite row to dictionary to mimic MySQL's dictionary cursor."""
        d = {}
        for idx, col in enumerate(cursor.description):
            d[col[0]] = row[idx]
        return d
    
    def _transform_query_for_sqlite(self, query: str, params: tuple) -> tuple:
        """Transform MySQL query format (%s) to SQLite format (?)."""
        # Replace %s with ? for SQLite
        # Count %s occurrences to verify param count
        placeholders_count = query.count('%s')
        
        if placeholders_count != len(params):
            raise ValueError(f"Parameter count mismatch: {placeholders_count} placeholders for {len(params)} parameters")
        
        transformed_query = query.replace('%s', '?')
        print("Transformed query: ", transformed_query)
        return transformed_query, params
    
    def close(self) -> None:
        """Close cursor and connection."""
        try:
            if self.cursor_proxy._cursor:
                self.cursor_proxy.close()
            if self.connection_proxy._connection:
                self.connection_proxy.close()
        except Exception as e:
            print(f"Error closing connection: {e}")

    def last_insert_id(self) -> int:
        """Get the last inserted ID."""
        if not self.connection_proxy._connection:
            return -1
            
        try:
            if self.db_type == 'mysql':
                self.cursor_proxy.execute("SELECT LAST_INSERT_ID()")
                result = self.cursor_proxy.fetchone()
                return result["LAST_INSERT_ID()"] if result else -1
            elif self.db_type == 'sqlite':
                return self.cursor_proxy._cursor.lastrowid
        except Exception as e:
            print(f"Error getting last insert ID: {e}")
            return -1

class DbManager:
    def __init__(self):
        self.connection: Optional[MySQLConnection | PooledMySQLConnection] = None
        self.cursor: Any = None
        self.id_per_sock: Dict[Any, int] = {}

    def get_is_sock_logged(self, sock: Any) -> bool:
        return sock in self.id_per_sock

    def get_id_per_sock(self, sock: Any) -> int:
        return self.id_per_sock.get(sock, -1)

    def connect_to_db(self, db_config: Dict[str, Any]) -> None:
        """Connect to MySQL database."""
        # try:
        #     self.connection = mysql.connector.connect(**db_config)
        #     self.cursor = self.connection.cursor(dictionary=True, buffered=True)
        #     self.is_sqlite=False
        #     print("Connected to database")
        # except Error as e:
        #     print(f"Error connecting to database: {e}")
        db = DBConnection()
        db.connect(db_config)
        self.connection = db.connection 
        self.cursor = db.cursor
    def connect_to_sqlite(self, db_config: Dict[str,Any]) -> None:
        db = DBConnection()
        db.connect({
            'db_type':  'sqlite',
            'database': db_config['database']
        })
        self.connection = db.connection
        self.cursor     = db.cursor

    def get_id_by_username(self, username: str) -> int:
        query = "SELECT id FROM User WHERE username = %s"
        self.cursor.execute(query, (username,))
        result = self.cursor.fetchone()
        return result["id"] if result else -1

    def insert_user(self, username: str, password_hash: str, salt: bytes) -> bool:
        """Insert a new user into the database."""
        try:
            query = """
                INSERT INTO user (username, hashedPass, salt, isPublic)
                VALUES (%s, %s, %s, %s)
            """
            print("Running query: ",query)
            self.cursor.execute(
                query, (username, password_hash, base64.b64encode(salt).decode(), 0)
            )
            self.connection.commit()
            print("Created user")
            return True
        except Exception as e:
            print(f"Error inserting user: {e}")
            return False

    def share_summary(
        self,
        summary_id: int,
        owner_id: int,
        user_to_share_with_id: int,
        permission_type: str,
    ) -> bool:
        """Verify if the user owns the summary, then share it with another user."""
        try:
            # 1. Verify ownership: Check if the user is the owner of the summary
            query = """
                SELECT ownerId FROM summary WHERE id = %s
            """
            self.cursor.execute(query, (summary_id,))
            result = self.cursor.fetchone()

            # If no result is found or the owner doesn't match
            if result is None or result["ownerId"] != owner_id:
                print("User does not own this summary.")
                return False

            # 2. Share the summary: Insert permission record to share with another user
            query = """
                INSERT INTO permission (summaryId, userId, permissionType)
                VALUES (%s, %s, %s)
            """
            self.cursor.execute(
                query, (summary_id, user_to_share_with_id, permission_type)
            )
            self.connection.commit()

            print(
                f"Summary {summary_id} shared with user {user_to_share_with_id} with {permission_type} permission."
            )
            return True
        except Error as e:
            print(f"Error sharing summary: {e}")
            return False

    # def get_user(self, username: str) -> Optional[User]:
    #     """Get user by username."""
    #     try:
    #         query = "SELECT * FROM User WHERE username = %s"
    #         self.cursor.execute(query, (username,))
    #         user = self.cursor.fetchone()
    #         if user:
    #             return User(**user)
    #         return None
    #     except Error as e:
    #         print(f"Error getting user: {e}")
    #         return None
    #
    def get_salt(self, username: str) -> Optional[bytes]:
        """Get salt for a user."""
        try:
            query = "SELECT salt FROM User WHERE username = %s"
            self.cursor.execute(query, (username,))
            result = self.cursor.fetchone()
            return base64.b64decode(result["salt"]) if result else b""
        except Error as e:
            print(f"Error fetching salt: {e}")
            return b""

    # def get_user_by_id(self, user_id: str) -> Optional[User]:
    #     """Get user by ID."""
    #     try:
    #         query = "SELECT * FROM User WHERE id = %s"
    #         self.cursor.execute(query, (user_id,))
    #         user_data = self.cursor.fetchone()
    #         if user_data:
    #             return User(**user_data)
    #         return None
    #     except Error as e:
    #         print(f"Error getting user by ID: {e}")
    #         return None
    #
    def authenticate_user(self, username: str, password_hash: str) -> Optional[User]:
        """Authenticate user by username and password hash."""
        try:
            query = "SELECT * FROM User WHERE username = %s AND hashedPass = %s"
            self.cursor.execute(
                query,
                (
                    username,
                    password_hash,
                ),
            )
            user_data = self.cursor.fetchone()
            print("User data: ", user_data)
            if user_data:
                return User(**user_data)
            return None
        except Error as e:
            print(f"Error authenticating user: {e}")
            return None

    # def update_user_password(self, username: str, new_password_hash: str) -> bool:
    #     """Update user password."""
    #     try:
    #         query = "UPDATE User SET hashedPass = %s WHERE username = %s"
    #         self.cursor.execute(
    #             query,
    #             (
    #                 new_password_hash,
    #                 username,
    #             ),
    #         )
    #         self.connection.commit()
    #         return True
    #     except Error as e:
    #         print(f"Error updating password: {e}")
    #         return False

    def _extract_links(self, content: str) -> Tuple[str, Dict[str, str]]:
        """
        Extract links from content in the format "###link {name}" ending with a newline.
        Returns processed content and dictionary of {link_title: link_id}.
        """
        # Pattern to match ###link {name} ending with a newline
        pattern = r"###link\s+([^\n]+)\n"
        links = {}

        # Find all links
        matches = re.findall(pattern, content)
        print("matches for links: ", matches)
        # Process each link
        for match in matches:
            link_title = match.strip()
            # Get the summary ID based on the title
            summary_id = self._get_summary_id_by_title(link_title)
            print(f"sid: {summary_id} for link: {link_title}")
            if summary_id:
                links[link_title] = summary_id

        return content, links

    def _get_summary_id_by_title(self, title: str) -> Optional[int]:
        """Get summary ID by title."""
        try:
            query = "SELECT id FROM Summary WHERE shareLink = %s"
            self.cursor.execute(query, (title,))
            result = self.cursor.fetchone()
            return result["id"] if result else None
        except Error as e:
            print(f"Error fetching summary ID by title: {e}")
            return None

    def _save_links(self, source_id: int, links: Dict[str, str]) -> None:
        """Save links between summaries in the database."""
        try:
            for link_text, target_id in links.items():
                query = """
                    INSERT INTO links (source_summary_id, target_summary_id, link_text)
                    VALUES (%s, %s, %s)
                """
                self.cursor.execute(query, (source_id, target_id, link_text))

            self.connection.commit()
            print(f"Saved {len(links)} links for summary {source_id}")
        except Error as e:
            print(f"Error saving links: {e}")

    def insert_summary(
        self, title: str, content: str, created_by: int, font: str
    ) -> int:
        """Insert new summary and save to disk, return its ID."""
        try:
            # Get the current maximum ID
            self.cursor.execute("SELECT MAX(id) FROM Summary")
            max_id_before = self.cursor.fetchone()["MAX(id)"] or 0

            # Create directory for user if it doesn't exist
            user_dir = os.path.join("data", str(created_by))
            os.makedirs(user_dir, exist_ok=True)

            # Generate unique filename
            base_filename = f"{title.replace(' ', '_')}.md"
            filepath = os.path.join(user_dir, base_filename)

            # Check and modify filename if it already exists
            counter = 1
            while os.path.exists(filepath):
                filename = f"{title.replace(' ', '_')}({counter}).md"
                filepath = os.path.join(user_dir, filename)
                counter += 1

            # Process content to extract links
            processed_content, links = self._extract_links(content)

            # Write content to file
            with open(filepath, "w", encoding="utf-8") as f:
                f.write(processed_content)

            # Insert summary record
            query = """
                INSERT INTO Summary (ownerId, shareLink, path_to_summary, font)
                VALUES (%s, %s, %s, %s)
            """
            self.cursor.execute(query, (created_by, title, filepath, font))
            self.connection.commit()

            # Get the maximum ID after insertion
            self.cursor.execute("SELECT MAX(id) FROM Summary")
            max_id_after = self.cursor.fetchone()["MAX(id)"] or 0

            new_summary_id = max_id_after if max_id_after > max_id_before else -1

            # Save links if insertion was successful
            if new_summary_id > 0 and links:
                self._save_links(new_summary_id, links)

            return new_summary_id

        except (Error, IOError) as e:
            print(f"Error inserting summary: {e}")
            return -1

    def save_summary(self, sid: int, content: str) -> bool:
        """Save updated summary content and process links."""
        try:
            query = "SELECT path_to_summary FROM Summary WHERE id = %s"
            self.cursor.execute(query, (sid,))
            result = self.cursor.fetchone()
            if not result:
                return False

            filepath = result["path_to_summary"]

            # Process content to extract and update links
            processed_content, links = self._extract_links(content)

            with open(filepath, "w", encoding="utf-8") as f:
                f.write(processed_content)

            # Update links for this summary
            self._update_links(sid, links)

            return True
        except (Error, IOError) as e:
            print(f"Error saving summary: {e}")
            return False

    def _update_links(self, source_id: int, links: Dict[str, str]) -> None:
        """Update links between summaries in the database."""
        try:
            # First delete all existing links from this source
            delete_query = """
                DELETE FROM links WHERE source_summary_id = %s
            """
            self.cursor.execute(delete_query, (source_id,))

            # Then insert new links
            if links:
                self._save_links(source_id, links)

            self.connection.commit()
        except Error as e:
            print(f"Error updating links: {e}")

    def _delete_links(self, summary_id: str) -> None:
        """Delete all links associated with a summary."""
        try:
            # Delete links where this summary is the source
            query1 = "DELETE FROM links WHERE source_summary_id = %s"
            self.cursor.execute(query1, (summary_id,))

            # Delete links where this summary is the target
            query2 = "DELETE FROM links WHERE target_summary_id = %s"
            self.cursor.execute(query2, (summary_id,))

            self.connection.commit()
        except Error as e:
            print(f"Error deleting links: {e}")

    def get_summary(self, summary_id: str) -> Optional[Summary]:
        """Get summary by ID, including file contents."""
        try:
            query = "SELECT * FROM Summary WHERE id = %s"
            self.cursor.execute(query, (summary_id,))
            summary_data = self.cursor.fetchone()

            if summary_data:
                # Read file contents if path exists
                if summary_data["path_to_summary"] and os.path.exists(
                    summary_data["path_to_summary"]
                ):
                    with open(
                        summary_data["path_to_summary"], "r", encoding="utf-8"
                    ) as f:
                        summary_data["content"] = f.read()
                return Summary(**summary_data)

            return None

        except (Error, IOError) as e:
            print(f"Error getting summary: {e}")
            return None

    def get_summary_by_link(self, link: str) -> Optional[Summary]:
        """Get summary by share link."""
        try:
            query = "SELECT * FROM Summary WHERE LOWER(shareLink) = LOWER(%s)"
            self.cursor.execute(query, (link,))
            summary_data = self.cursor.fetchone()

            if summary_data:
                # Read file contents if path exists
                if summary_data["path_to_summary"] and os.path.exists(
                    summary_data["path_to_summary"]
                ):
                    with open(
                        summary_data["path_to_summary"], "r", encoding="utf-8"
                    ) as f:
                        summary_data["content"] = f.read()
                return Summary(**summary_data)

            return None

        except (Error, IOError) as e:
            print(f"Error getting summary: {e}")
            return None

    def update_summary(self, summary_id: str, content: str, font=None) -> bool:
        """Update a summary's shareLink and optionally its content."""
        print("Updating summary")
        try:
            # Fetch current summary to get existing path
            query = "SELECT path_to_summary FROM Summary WHERE id = %s"
            self.cursor.execute(query, (summary_id,))
            result = self.cursor.fetchone()

            if not result:
                return False

            filepath = result["path_to_summary"]
            # first copy both the file, and graph to:
            # /save/{sid}/graph-(timestamp).pkl
            # /save/{sid}/summary-(timestamp).md
            # Create directory for saving if it doesn't exist
            sid = summary_id
            print("Saving the summary with sid: ", sid)
            timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
            save_dir = os.path.join("save", str(sid), str(timestamp))
            os.makedirs(save_dir, exist_ok=True)
            # Get the current timestamp
            # Copy the graph file
            graph_file = os.path.join("data", "graphs", f"graph_{sid}.pkl")
            if os.path.exists(graph_file):
                shutil.copy(graph_file, os.path.join(save_dir, f"graph.pkl"))
            # Copy the summary file
            else:
                print("Might just not have a graph")
            summary_file = filepath  # os.path.join("data", str(sid), f"{sid}.md")
            if os.path.exists(summary_file):
                shutil.copy(summary_file, os.path.join(save_dir, f"summary.md"))
            else:
                print("Something went really wrong")
            # Update file content if provided
            if content and filepath:
                # Process content to extract and update links
                processed_content, links = self._extract_links(content)

                with open(filepath, "w", encoding="utf-8") as f:
                    f.write(processed_content)

                # Update links for this summary
                self._update_links(int(summary_id), links)

            # Update database record
            update_query = "UPDATE Summary SET font = %s WHERE id = %s"
            self.cursor.execute(update_query, (font, summary_id))
            self.connection.commit()

            return True

        except (Error, IOError) as e:
            print(f"Error updating summary: {e}")
            return False

    def delete_summary(self, summary_id: str) -> bool:
        """Delete a summary from database and file system."""
        try:
            # Fetch filepath before deletion
            query = "SELECT path_to_summary FROM Summary WHERE id = %s"
            self.cursor.execute(query, (summary_id,))
            result = self.cursor.fetchone()

            # Delete links associated with this summary
            self._delete_links(summary_id)

            # Delete from database
            delete_query = "DELETE FROM Summary WHERE id = %s"
            self.cursor.execute(delete_query, (summary_id,))
            self.connection.commit()

            # Delete file if it exists
            if (
                result
                and result["path_to_summary"]
                and os.path.exists(result["path_to_summary"])
            ):
                os.remove(result["path_to_summary"])

            return True

        except (Error, IOError) as e:
            print(f"Error deleting summary: {e}")
            return False

    def get_event(self, uid, title):
        """Get an event by title for a user."""
        try:
            query = """
            SELECT * FROM Event
            WHERE userId = %s AND event_title = %s
            """
            self.cursor.execute(query, (uid, title))
            result = self.cursor.fetchone()
            return result  # Event(**result) if result else None
        except Error as e:
            print(f"Error fetching event: {e}")
            return None

    def insert_event(self, user_id: int, title: str, datetime_str: str) -> bool:
        """Insert a new event for a user with datetime."""
        try:
            query = """
            INSERT INTO Event (userId, event_title, event_date)
            VALUES (%s, %s, %s)
            """
            # Pass values twice - once for the INSERT and once for the EXISTS condition
            self.cursor.execute(query, (user_id, title, datetime_str))
            self.connection.commit()
            return True
        except Error as e:
            print(f"Error inserting event: {e}")
            return False

    def get_events(self, user_id: int) -> List[Dict[str, Any]]:
        """Get all events for a user."""
        try:
            query = "SELECT * FROM Event WHERE userid = %s ORDER BY event_date ASC"
            self.cursor.execute(query, (user_id,))
            events = self.cursor.fetchall()
            return events
        except Error as e:
            print(f"Error fetching events: {e}")
            return []

    def update_event(self, event_id: int, new_title: str, new_date: str) -> bool:
        """Update an existing event."""
        try:
            query = "UPDATE Event SET event_title = %s, event_date = %s WHERE id = %s"
            self.cursor.execute(
                query,
                (
                    new_title,
                    new_date,
                    event_id,
                ),
            )
            self.connection.commit()
            return True
        except Error as e:
            print(f"Error updating event: {e}")
            return False

    def delete_event(self, event_id: str, user_id: int) -> bool:
        """Delete an event if it belongs to the specified user."""
        try:
            # First verify the event belongs to this user
            check_query = """
            SELECT id FROM Event
            WHERE id = %s AND userId = %s
            """
            self.cursor.execute(check_query, (event_id, user_id))
            if not self.cursor.fetchone():
                print("Event doesn't exist or doesn't belong to this user")
                return False

            # Now delete the event
            delete_query = """
            DELETE FROM Event
            WHERE id = %s AND userId = %s
            """
            self.cursor.execute(delete_query, (event_id, user_id))
            self.connection.commit()
            print("Removed event:  ", event_id, " from user: ", user_id)
            return True
        except Error as e:
            print(f"Error deleting event: {e}")
            return False

    def close_connection(self) -> None:
        """Close the database connection."""
        if self.connection:
            self.cursor.close()
            self.connection.close()

    def get_summary_share_link(self, id: int) -> str:
        """Get the share link for a summary."""
        try:
            query = "SELECT shareLink FROM Summary WHERE id = %s"
            self.cursor.execute(query, (id,))
            result = self.cursor.fetchone()
            return result["shareLink"] if result else ""
        except Error as e:
            print(f"Error fetching summary share link: {e}")
            return ""

    def update_permission(self, summary_id: int, user_id: int, new_perm: str) -> bool:
        """
        Update permission for a specific user and summary.

        :param summary_id: The ID of the summary whose permission is being updated.
        :param user_id: The ID of the user whose permission is being updated.
        :param new_perm: The new permission to set ('view', 'edit', 'comment').
        :return: True if the update was successful, False otherwise.
        """
        try:
            query = """
                UPDATE permission
                SET permissionType = %s
                WHERE summaryId = %s AND userId = %s
            """
            self.cursor.execute(query, (new_perm, summary_id, user_id))
            self.connection.commit()
            return (
                self.cursor.rowcount > 0
            )  # Return True if at least one row was updated
        except Error as e:
            print(f"Error updating permission: {e}")
            return False

    def get_summary_times(self, id: int) -> List[datetime.datetime]:
        """Get creation and update times of a summary."""
        try:
            query = "SELECT createTime, updateTime FROM Summary WHERE id = %s"
            self.cursor.execute(query, (id,))
            result = self.cursor.fetchone()
            return [result["createTime"], result["updateTime"]] if result else []
        except Error as e:
            print(f"Error fetching summary times: {e}")
            return []

    def get_all_by_user(self, user_id: int) -> List[Summary]:
        """Get all summaries created by a user."""
        try:
            query = "SELECT * FROM Summary WHERE ownerId = %s"
            self.cursor.execute(query, (user_id,))
            summaries = self.cursor.fetchall()
            return [Summary(**summar) for summar in summaries]
        except Error as e:
            print(f"Error fetching all summaries by user: {e}")
            return []

    def get_all_user_can_access(
        self, user_id: int, do_cont=True, size_read=200
    ) -> List[Summary]:
        """Get all summaries the user can access, including owned and permitted ones."""
        try:
            query = """
                SELECT DISTINCT s.*
                FROM summary s
                LEFT JOIN permission p ON s.id = p.summaryId AND p.userId = %s
                WHERE s.ownerId = %s OR p.userId = %s
            """
            self.cursor.execute(query, (user_id, user_id, user_id))
            summaries = self.cursor.fetchall()
            summs = [Summary(**su) for su in summaries]
            if do_cont:
                for summ in summs:
                    if summ.path_to_summary and os.path.exists(summ.path_to_summary):
                        with open(summ.path_to_summary, "r", encoding="utf-8") as f:
                            # if size_read == -1 :
                            #     summ.content = f.read()#un needed but clearer
                            # else:
                            #     summ.content = f.read(size_read)#preview
                            summ.content = f.read(size_read)
            return summs
        except Error as e:
            print(f"Error fetching summaries user can access: {e}")
            return []

    def can_access(self, sid, user_id):
        """
        Check if a user can access a summary based on ownership or permissions.
        Returns True if the user can access the summary, False otherwise.
        """
        try:
            query = """
                SELECT COUNT(*) as count
                FROM Summary s
                LEFT JOIN permission p ON s.id = p.summaryId AND p.userId = %s
                WHERE s.id = %s AND (s.ownerId = %s OR p.userId = %s)
            """
            self.cursor.execute(query, (user_id, sid, user_id, user_id))
            result = self.cursor.fetchone()
            return result["count"] > 0
        except Error as e:
            print(f"Error checking access: {e}")
            return False

    def get_graph(self, summary_id: int) -> List[Node]:
        """
        Build a graph representation for a summary and its connections.
        Returns a list of Node objects representing the graph structure.
        """
        try:
            # Get the current summary
            query = "SELECT id, shareLink FROM Summary WHERE id = %s"
            self.cursor.execute(query, (summary_id,))
            current_summary = self.cursor.fetchone()

            if not current_summary:
                return []

            # Initialize the graph with the current summary as root
            root_node = Node(
                id=current_summary["id"],
                name=current_summary["shareLink"],
                type="summary",
                children=[],
            )

            # Find parent summaries (summaries that link to this one)
            parent_query = """
                SELECT s.id, s.shareLink
                FROM Summary s
                JOIN links l ON s.id = l.source_summary_id
                WHERE l.target_summary_id = %s
            """
            self.cursor.execute(parent_query, (summary_id,))
            parents = self.cursor.fetchall()

            # Find child summaries (summaries that this one links to)
            child_query = """
                SELECT s.id, s.shareLink
                FROM Summary s
                JOIN links l ON s.id = l.target_summary_id
                WHERE l.source_summary_id = %s
            """
            self.cursor.execute(child_query, (summary_id,))
            children = self.cursor.fetchall()

            # Add children to the root node
            for child in children:
                child_node = Node(
                    id=child["id"], name=child["shareLink"], type="child", children=[]
                )
                root_node.children.append(child_node)

            # Create parent nodes
            parent_nodes = []
            for parent in parents:
                parent_node = Node(
                    id=parent["id"],
                    name=parent["shareLink"],
                    type="parent",
                    children=[root_node],  # The current node is a child of each parent
                )
                parent_nodes.append(parent_node)

            # Combine into a single result
            result = [root_node]
            result.extend(parent_nodes)

            # Optionally save the graph structure using pickle
            graph_dir = "data/graphs"
            os.makedirs(graph_dir, exist_ok=True)
            graph_path = os.path.join(graph_dir, f"graph_{summary_id}.pkl")

            with open(graph_path, "wb") as f:
                pickle.dump(result, f)

            return result

        except (Error, IOError) as e:
            print(f"Error generating graph: {e}")
            return []


logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)

# Generate unique identifiers for test runs to minimize collisions
RUN_ID = uuid.uuid4().hex[:8]
TEST_USER_1_USERNAME = f"test_user1_{RUN_ID}"
TEST_USER_2_USERNAME = f"test_user2_{RUN_ID}"
TEST_USER_3_USERNAME = f"test_user3_{RUN_ID}"  # For sharing/permissions
TEST_PASSWORD = "password123"
TEST_SALT = os.urandom(16)  # Generate a random salt for testing
TEST_HASHED_PASS = base64.b64encode(TEST_SALT + TEST_PASSWORD.encode()).decode(
    "utf-8"
)  # Dummy hash for testing

TEST_SUMMARY_1_TITLE = f"Test Summary 1 {RUN_ID}"
TEST_SUMMARY_2_TITLE = f"Test Summary 2 {RUN_ID}"
TEST_SUMMARY_3_TITLE = f"Test Summary 3 Links {RUN_ID}"  # For link tests
TEST_SUMMARY_CONTENT = "This is the content."
TEST_SUMMARY_FONT = "Arial"

TEST_DATA_DIR = "data"  # Base directory for summary files


# --- Test Class ---
class TestDbManager(unittest.TestCase):
    # Renamed class variables to avoid conflict with test discovery
    db_manager = None
    setup_user1_id = -1
    setup_user2_id = -1
    setup_user3_id = -1
    setup_summary1_id = -1
    setup_summary2_id = -1
    setup_summary3_id = -1  # Will be set during link tests if needed
    setup_event1_id = -1
    setup_event2_id = -1

    results = {"passed": 0, "failed": 0, "total": 0}

    @classmethod
    def setUpClass(cls):
        """Set up database connection and initial data for all tests."""
        load_dotenv()
        required_vars = [
            "DB_HOST",
            "DB_USERNAME",
            "DB_PASSWORD",
            "DB_TESTNAME",
            "DB_PORT",
        ]
        if not all(os.getenv(var) for var in required_vars):
            raise EnvironmentError(
                "Missing required database environment variables for testing."
            )

        cls.db_manager = DbManager()
        db_config = {
            "host": os.getenv("DB_HOST"),
            "user": os.getenv("DB_USERNAME"),
            "password": os.getenv("DB_PASSWORD"),
            "database": os.getenv("DB_TESTNAME"),
            "port": os.getenv("DB_PORT"),
        }
        try:
            cls.db_manager.connect_to_db(db_config)
            logging.info("Database connection established for tests.")

            # Ensure data directory exists
            os.makedirs(TEST_DATA_DIR, exist_ok=True)

            # --- Pre-create test users ---
            if not cls.db_manager.insert_user(
                TEST_USER_1_USERNAME, TEST_HASHED_PASS, TEST_SALT
            ):
                raise Exception(
                    f"Failed to create initial test user: {TEST_USER_1_USERNAME}"
                )
            cls.setup_user1_id = cls.db_manager.get_id_by_username(TEST_USER_1_USERNAME)
            if cls.setup_user1_id == -1:
                raise Exception("Failed to get ID for user 1")

            if not cls.db_manager.insert_user(
                TEST_USER_2_USERNAME, TEST_HASHED_PASS, TEST_SALT
            ):
                raise Exception(
                    f"Failed to create initial test user: {TEST_USER_2_USERNAME}"
                )
            cls.setup_user2_id = cls.db_manager.get_id_by_username(TEST_USER_2_USERNAME)
            if cls.setup_user2_id == -1:
                raise Exception("Failed to get ID for user 2")

            if not cls.db_manager.insert_user(
                TEST_USER_3_USERNAME, TEST_HASHED_PASS, TEST_SALT
            ):
                raise Exception(
                    f"Failed to create initial test user: {TEST_USER_3_USERNAME}"
                )
            cls.setup_user3_id = cls.db_manager.get_id_by_username(TEST_USER_3_USERNAME)
            if cls.setup_user3_id == -1:
                raise Exception("Failed to get ID for user 3")

            logging.info(
                f"Created test users: {cls.setup_user1_id}, {cls.setup_user2_id}, {cls.setup_user3_id}"
            )

            # --- Pre-create test summaries (needed for many tests) ---
            cls.setup_summary1_id = cls.db_manager.insert_summary(
                TEST_SUMMARY_1_TITLE,
                TEST_SUMMARY_CONTENT,
                cls.setup_user1_id,
                TEST_SUMMARY_FONT,
            )
            if cls.setup_summary1_id == -1:
                raise Exception("Failed to create summary 1")

            cls.setup_summary2_id = cls.db_manager.insert_summary(
                TEST_SUMMARY_2_TITLE,
                "Content for summary 2",
                cls.setup_user2_id,
                "Times New Roman",
            )
            if cls.setup_summary2_id == -1:
                raise Exception("Failed to create summary 2")

            logging.info(
                f"Created test summaries: {cls.setup_summary1_id}, {cls.setup_summary2_id}"
            )

            # --- Pre-create test events ---
            event1_time = datetime.datetime.now().isoformat(sep=" ", timespec="seconds")
            if cls.db_manager.insert_event(
                cls.setup_user1_id, f"Event 1 {RUN_ID}", event1_time
            ):
                # Need to fetch the ID
                events = cls.db_manager.get_events(cls.setup_user1_id)
                cls.setup_event1_id = next(
                    (
                        e["id"]
                        for e in events
                        if e["event_title"] == f"Event 1 {RUN_ID}"
                    ),
                    -1,
                )
                if cls.setup_event1_id == -1:
                    raise Exception("Failed to get ID for event 1")
            else:
                raise Exception("Failed to create event 1")

            event2_time = (
                datetime.datetime.now() + datetime.timedelta(days=1)
            ).isoformat(sep=" ", timespec="seconds")
            if cls.db_manager.insert_event(
                cls.setup_user1_id, f"Event 2 {RUN_ID}", event2_time
            ):
                events = cls.db_manager.get_events(cls.setup_user1_id)
                cls.setup_event2_id = next(
                    (
                        e["id"]
                        for e in events
                        if e["event_title"] == f"Event 2 {RUN_ID}"
                    ),
                    -1,
                )
                if cls.setup_event2_id == -1:
                    raise Exception("Failed to get ID for event 2")
            else:
                raise Exception("Failed to create event 2")

            logging.info(
                f"Created test events: {cls.setup_event1_id}, {cls.setup_event2_id}"
            )

        except Exception as e:
            logging.error(f"CRITICAL ERROR during setUpClass: {e}")
            if cls.db_manager:
                cls.db_manager.close_connection()
            raise  # Propagate exception to stop tests

    @classmethod
    def tearDownClass(cls):
        """Clean up database connection and test data."""
        if cls.db_manager and cls.db_manager.connection:
            logging.info("Starting cleanup...")
            try:
                # Clean up test data in reverse order of creation/dependency
                # Delete events first
                if cls.setup_event1_id != -1:
                    cls.db_manager.delete_event(cls.setup_event1_id, cls.setup_user1_id)
                if cls.setup_event2_id != -1:
                    cls.db_manager.delete_event(cls.setup_event2_id, cls.setup_user1_id)

                # Delete summaries (which should handle files and links)
                if cls.setup_summary1_id != -1:
                    cls.db_manager.delete_summary(cls.setup_summary1_id)
                if cls.setup_summary2_id != -1:
                    cls.db_manager.delete_summary(cls.setup_summary2_id)
                # Clean up summary 3 if it was created and ID stored
                if cls.setup_summary3_id != -1:
                    cls.db_manager.delete_summary(cls.setup_summary3_id)
                else:  # Fallback check by title if ID wasn't stored correctly
                    summary3 = cls.db_manager.get_summary_by_link(TEST_SUMMARY_3_TITLE)
                    if summary3:
                        cls.db_manager.delete_summary(summary3.id)

                # Delete permissions explicitly if needed (though summary deletion might cascade)
                # Use executemany for potentially cleaner permission deletion
                perm_users = [
                    cls.setup_user1_id,
                    cls.setup_user2_id,
                    cls.setup_user3_id,
                ]
                perm_users_clean = [
                    (uid,) for uid in perm_users if uid != -1
                ]  # Filter out -1 IDs
                if perm_users_clean:
                    cls.db_manager.cursor.executemany(
                        "DELETE FROM permission WHERE userId = %s", perm_users_clean
                    )
                    cls.db_manager.connection.commit()
                    logging.info(
                        f"Cleaned permissions for users: {[uid[0] for uid in perm_users_clean]}"
                    )

                # Delete users (assuming FK constraints allow it or are handled)
                # NOTE: Requires a delete_user method or manual SQL
                user_ids_to_delete = [
                    cls.setup_user1_id,
                    cls.setup_user2_id,
                    cls.setup_user3_id,
                ]
                user_ids_clean = [(uid,) for uid in user_ids_to_delete if uid != -1]
                if user_ids_clean:
                    cls.db_manager.cursor.executemany(
                        "DELETE FROM User WHERE id = %s", user_ids_clean
                    )
                    cls.db_manager.connection.commit()
                    logging.info(
                        f"Deleted test users: {[uid[0] for uid in user_ids_clean]}"
                    )

                # Clean up data directories if they exist and are empty
                for user_id in [
                    cls.setup_user1_id,
                    cls.setup_user2_id,
                    cls.setup_user3_id,
                ]:
                    if user_id != -1:
                        user_dir = os.path.join(TEST_DATA_DIR, str(user_id))
                        if os.path.exists(user_dir):
                            try:
                                # Check if empty first
                                if not os.listdir(user_dir):
                                    os.rmdir(user_dir)
                                    logging.info(
                                        f"Removed empty test directory: {user_dir}"
                                    )
                                else:
                                    # If not empty after summary deletion, try deleting contents then dir
                                    print("Rming: ", user_dir)
                                    if input("Rm it? ").lower() == "y":
                                        shutil.rmtree(user_dir)
                                        logging.warning(
                                            f"Force removed non-empty test directory: {user_dir}"
                                        )
                            except OSError as e:
                                logging.error(
                                    f"Could not remove test directory {user_dir}: {e}"
                                )

            except Error as e:
                logging.error(f"Error during database cleanup: {e}")
            except Exception as e:
                logging.error(f"Unexpected error during cleanup: {e}")
            finally:
                cls.db_manager.close_connection()
                logging.info("Database connection closed after tests.")

        # Report results
        total = cls.results["total"]
        passed = cls.results["passed"]
        failed = cls.results["failed"]
        success_rate = (passed / total * 100) if total > 0 else 0
        print("\n--- Test Summary ---")
        print(f"Total test cases executed: {total}")
        print(f"Passed: {passed}")
        print(f"Failed: {failed}")
        print(f"Success Rate: {success_rate:.2f}%")
        print("--------------------\n")

    def run_test_case(self, func, args, expected_success, case_desc):
        """Helper method to run a single test case and log results."""
        self.results["total"] += 1
        log_prefix = f"{func.__name__} - {case_desc}"
        try:
            result = func(*args)
            # Determine if the outcome matches the expectation
            outcome_matches_expectation = False
            if expected_success:
                if isinstance(result, bool) and result:
                    outcome_matches_expectation = True
                elif isinstance(result, int) and result > 0:
                    outcome_matches_expectation = True  # e.g., insert returning ID
                elif isinstance(result, (list, bytes, str)) and result:
                    outcome_matches_expectation = (
                        True  # e.g., get returning non-empty list/bytes/string
                    )
                elif result is not None and not isinstance(
                    result, (bool, int, list, bytes, str)
                ):
                    outcome_matches_expectation = True  # e.g., get returning object
                elif isinstance(result, list) and expected_success:
                    outcome_matches_expectation = True  # Allow empty list as success if expected (e.g., get_events for user with none)

            else:  # Not expected_success (failure expected)
                if isinstance(result, bool) and not result:
                    outcome_matches_expectation = True
                elif result == -1:
                    outcome_matches_expectation = (
                        True  # e.g., get_id, insert_summary failure
                    )
                elif result is None:
                    outcome_matches_expectation = (
                        True  # e.g., get non-existent, auth fail
                    )
                elif isinstance(result, list) and not result:
                    outcome_matches_expectation = True  # e.g., get_events error
                elif isinstance(result, bytes) and not result:
                    outcome_matches_expectation = True  # e.g., get_salt non-existent

            # if outcome_matches_expectation:
            #     logging.info(
            #         f"{log_prefix}: PASSED (Expected: {'Success' if expected_success else 'Failure'}, Result: {str(result)[:100]}) - GREEN"
            #     )  # Limit result log length
            #     self.results["passed"] += 1
            #     self.assertTrue(True)  # Mark unittest framework positively
            # else:
            #     logging.error(
            #         f"{log_prefix}: FAILED (Expected: {'Success' if expected_success else 'Failure'}, Result: {str(result)[:100]}) - RED"
            #     )  # Limit result log length
            #     self.results["failed"] += 1
            #     self.fail(
            #         f"{log_prefix}: Outcome mismatch."
            #     )  # Mark unittest framework negatively

            return result  # Return actual result for further potential assertions
        except Exception as e:
            log_msg = f"{log_prefix}: EXCEPTION ({type(e).__name__}: {e}) - "
            # Assuming "should fail" means non-True/non-positive return, not exception.
            # Thus, any exception is treated as a failure regardless of expected_success.
            log_msg += "RED (Exception occurred unexpectedly)"
            logging.error(log_msg, exc_info=True)  # Log traceback for exceptions
            self.results["failed"] += 1
            self.fail(log_msg)
            return None  # Indicate failure due to exception

    # --- Test Methods ---
    # Use TestDbManager.setup_... to access class variables storing IDs

    def test_01_get_id_by_username(self):
        logging.info("\n--- Testing get_id_by_username ---")
        # Success 1: Existing user 1
        user_id = self.run_test_case(
            self.db_manager.get_id_by_username,
            (TEST_USER_1_USERNAME,),
            True,
            "Success Case 1: Existing User 1",
        )
        self.assertEqual(user_id, TestDbManager.setup_user1_id)
        # Success 2: Existing user 2
        user_id = self.run_test_case(
            self.db_manager.get_id_by_username,
            (TEST_USER_2_USERNAME,),
            True,
            "Success Case 2: Existing User 2",
        )
        self.assertEqual(user_id, TestDbManager.setup_user2_id)
        # Failure 1: Non-existent user
        self.run_test_case(
            self.db_manager.get_id_by_username,
            (f"non_existent_{RUN_ID}",),
            False,
            "Failure Case 1: Non-existent User",
        )

    def test_02_insert_user(self):
        logging.info("\n--- Testing insert_user ---")
        # Success 1: New unique user
        unique_user_1 = f"insert_test_1_{RUN_ID}"
        self.run_test_case(
            self.db_manager.insert_user,
            (unique_user_1, TEST_HASHED_PASS, TEST_SALT),
            True,
            "Success Case 1: New Unique User",
        )
        # Success 2: Another new unique user
        unique_user_2 = f"insert_test_2_{RUN_ID}"
        self.run_test_case(
            self.db_manager.insert_user,
            (unique_user_2, TEST_HASHED_PASS, TEST_SALT),
            True,
            "Success Case 2: Another New Unique User",
        )
        # Failure 1: Duplicate username (using pre-created user 1)
        self.run_test_case(
            self.db_manager.insert_user,
            (TEST_USER_1_USERNAME, TEST_HASHED_PASS, TEST_SALT),
            False,
            "Failure Case 1: Duplicate Username",
        )
        # Cleanup added users manually for now
        self.db_manager.cursor.execute(
            "DELETE FROM User WHERE username IN (%s, %s)",
            (unique_user_1, unique_user_2),
        )
        self.db_manager.connection.commit()

    def test_03_get_salt(self):
        logging.info("\n--- Testing get_salt ---")
        # Success 1: Get salt for existing user 1
        salt1 = self.run_test_case(
            self.db_manager.get_salt,
            (TEST_USER_1_USERNAME,),
            True,
            "Success Case 1: Existing User 1",
        )
        self.assertEqual(salt1, TEST_SALT, "Salt mismatch for user 1")  # Specific check
        # Success 2: Get salt for existing user 2
        salt2 = self.run_test_case(
            self.db_manager.get_salt,
            (TEST_USER_2_USERNAME,),
            True,
            "Success Case 2: Existing User 2",
        )
        self.assertEqual(salt2, TEST_SALT, "Salt mismatch for user 2")  # Specific check
        # Failure 1: Get salt for non-existent user (expect None or b"")
        self.run_test_case(
            self.db_manager.get_salt,
            (f"non_existent_{RUN_ID}",),
            False,
            "Failure Case 1: Non-existent User",
        )

    def test_04_authenticate_user(self):
        logging.info("\n--- Testing authenticate_user ---")
        # Success 1: Correct credentials for user 1
        user1 = self.run_test_case(
            self.db_manager.authenticate_user,
            (TEST_USER_1_USERNAME, TEST_HASHED_PASS),
            True,
            "Success Case 1: Correct Credentials User 1",
        )
        self.assertIsInstance(user1, User, "Expected User object for successful auth")
        self.assertEqual(
            user1.id, TestDbManager.setup_user1_id, "Authenticated user ID mismatch"
        )
        # Success 2: Correct credentials for user 2
        user2 = self.run_test_case(
            self.db_manager.authenticate_user,
            (TEST_USER_2_USERNAME, TEST_HASHED_PASS),
            True,
            "Success Case 2: Correct Credentials User 2",
        )
        self.assertIsInstance(user2, User, "Expected User object for successful auth")
        self.assertEqual(
            user2.id, TestDbManager.setup_user2_id, "Authenticated user ID mismatch"
        )
        # Failure 1: Incorrect password for user 1
        self.run_test_case(
            self.db_manager.authenticate_user,
            (TEST_USER_1_USERNAME, "wrong_hash"),
            False,
            "Failure Case 1: Incorrect Password",
        )

    def test_05_insert_summary(self):
        logging.info("\n--- Testing insert_summary ---")
        # Success 1: Insert a new summary for user 1
        title_succ_1 = f"Insert Success 1 {RUN_ID}"
        sid1 = self.run_test_case(
            self.db_manager.insert_summary,
            (title_succ_1, "Content 1", TestDbManager.setup_user1_id, "Font1"),
            True,
            "Success Case 1: Valid Insertion",
        )
        self.assertIsInstance(sid1, int)
        self.assertGreater(sid1, 0, "Expected positive summary ID")
        # Success 2: Insert another summary for user 2
        title_succ_2 = f"Insert Success 2 {RUN_ID}"
        sid2 = self.run_test_case(
            self.db_manager.insert_summary,
            (title_succ_2, "Content 2", TestDbManager.setup_user2_id, "Font2"),
            True,
            "Success Case 2: Valid Insertion User 2",
        )
        self.assertIsInstance(sid2, int)
        self.assertGreater(sid2, 0, "Expected positive summary ID")
        self.assertNotEqual(sid1, sid2, "Summary IDs should be unique")
        # Failure 1: Insert summary with existing title (violates unique constraint assumed for shareLink)
        self.run_test_case(
            self.db_manager.insert_summary,
            (
                TEST_SUMMARY_1_TITLE,
                "Content Fail",
                TestDbManager.setup_user1_id,
                "FontFail",
            ),
            False,
            "Failure Case 1: Duplicate Title",
        )
        # Cleanup created summaries
        if sid1 > 0:
            self.db_manager.delete_summary(sid1)
        if sid2 > 0:
            self.db_manager.delete_summary(sid2)

    def test_06_get_summary(self):
        logging.info("\n--- Testing get_summary ---")
        # Success 1: Get existing summary 1
        summary1 = self.run_test_case(
            self.db_manager.get_summary,
            (TestDbManager.setup_summary1_id,),
            True,
            "Success Case 1: Existing Summary 1",
        )
        self.assertIsInstance(summary1, Summary)
        self.assertEqual(summary1.id, TestDbManager.setup_summary1_id)
        self.assertEqual(summary1.content, TEST_SUMMARY_CONTENT)  # Check content loaded
        # Success 2: Get existing summary 2
        summary2 = self.run_test_case(
            self.db_manager.get_summary,
            (TestDbManager.setup_summary2_id,),
            True,
            "Success Case 2: Existing Summary 2",
        )
        self.assertIsInstance(summary2, Summary)
        self.assertEqual(summary2.id, TestDbManager.setup_summary2_id)
        # Failure 1: Get non-existent summary ID
        self.run_test_case(
            self.db_manager.get_summary,
            (999999,),
            False,
            "Failure Case 1: Non-existent Summary ID",
        )

    def test_07_get_summary_by_link(self):
        logging.info("\n--- Testing get_summary_by_link ---")
        # Success 1: Get summary 1 by its link (case-insensitive)
        link1_upper = TEST_SUMMARY_1_TITLE.upper()
        summary1 = self.run_test_case(
            self.db_manager.get_summary_by_link,
            (link1_upper,),
            True,
            "Success Case 1: Existing Link (Upper Case)",
        )
        self.assertIsInstance(summary1, Summary)
        self.assertEqual(summary1.id, TestDbManager.setup_summary1_id)
        self.assertEqual(summary1.content, TEST_SUMMARY_CONTENT)
        # Success 2: Get summary 2 by its link (exact case)
        summary2 = self.run_test_case(
            self.db_manager.get_summary_by_link,
            (TEST_SUMMARY_2_TITLE,),
            True,
            "Success Case 2: Existing Link (Exact Case)",
        )
        self.assertIsInstance(summary2, Summary)
        self.assertEqual(summary2.id, TestDbManager.setup_summary2_id)
        # Failure 1: Get summary by non-existent link
        self.run_test_case(
            self.db_manager.get_summary_by_link,
            (f"non_existent_link_{RUN_ID}",),
            False,
            "Failure Case 1: Non-existent Link",
        )

    def test_08_share_summary(self):
        logging.info("\n--- Testing share_summary ---")
        # Success 1: User 1 shares summary 1 with User 2 (view)
        self.run_test_case(
            self.db_manager.share_summary,
            (
                TestDbManager.setup_summary1_id,
                TestDbManager.setup_user1_id,
                TestDbManager.setup_user2_id,
                "view",
            ),
            True,
            "Success Case 1: Share Owner's Summary (view)",
        )
        # Check permission table
        self.db_manager.cursor.execute(
            "SELECT permissionType FROM permission WHERE summaryId = %s AND userId = %s",
            (TestDbManager.setup_summary1_id, TestDbManager.setup_user2_id),
        )
        perm = self.db_manager.cursor.fetchone()
        self.assertIsNotNone(perm)
        self.assertEqual(perm["permissionType"], "view")
        # case isnt valid. it should be update_premissions or smh share_summary does insert not update
        # Success 2: User 1 updates share permission for User 2 to 'edit'
        # self.run_test_case(
        #     self.db_manager.share_summary,
        #     (
        #         TestDbManager.setup_summary1_id,
        #         TestDbManager.setup_user1_id,
        #         TestDbManager.setup_user2_id,
        #         "edit",
        #     ),
        #     True,
        #     "Success Case 2: Update Permission (edit)",
        # )
        # # Check permission table again
        # self.db_manager.cursor.execute(
        #     "SELECT permissionType FROM permission WHERE summaryId = %s AND userId = %s",
        #     (TestDbManager.setup_summary1_id, TestDbManager.setup_user2_id),
        # )
        # perm = self.db_manager.cursor.fetchone()
        # logging.info("PERMMMMMM: ",perm)
        # self.assertIsNotNone(perm)
        # self.assertEqual(perm["permissionType"], "edit")
        # Failure 1: User 2 tries to share User 1's summary
        self.run_test_case(
            self.db_manager.share_summary,
            (
                TestDbManager.setup_summary1_id,
                TestDbManager.setup_user2_id,
                TestDbManager.setup_user3_id,
                "view",
            ),
            False,
            "Failure Case 1: Non-owner Tries to Share",
        )

    def test_09_update_permission(self):
        logging.info("\n--- Testing update_permission ---")
        # Setup: Ensure user 1 shared summary 1 with user 3 ('view')
        self.db_manager.share_summary(
            TestDbManager.setup_summary1_id,
            TestDbManager.setup_user1_id,
            TestDbManager.setup_user3_id,
            "view",
        )

        # Success 1: Update permission for user 3 to 'edit'
        self.run_test_case(
            self.db_manager.update_permission,
            (TestDbManager.setup_summary1_id, TestDbManager.setup_user3_id, "edit"),
            True,
            "Success Case 1: Update Existing Permission ('view' to 'edit')",
        )
        # Check permission table
        self.db_manager.cursor.execute(
            "SELECT permissionType FROM permission WHERE summaryId = %s AND userId = %s",
            (TestDbManager.setup_summary1_id, TestDbManager.setup_user3_id),
        )
        perm = self.db_manager.cursor.fetchone()
        self.assertIsNotNone(perm)
        self.assertEqual(perm["permissionType"], "edit")

        # Success 2: Update permission for user 3 back to 'view'
        self.run_test_case(
            self.db_manager.update_permission,
            (TestDbManager.setup_summary1_id, TestDbManager.setup_user3_id, "view"),
            True,
            "Success Case 2: Update Existing Permission ('edit' to 'view')",
        )
        self.db_manager.cursor.execute(
            "SELECT permissionType FROM permission WHERE summaryId = %s AND userId = %s",
            (TestDbManager.setup_summary1_id, TestDbManager.setup_user3_id),
        )
        perm = self.db_manager.cursor.fetchone()
        self.assertIsNotNone(perm)
        self.assertEqual(perm["permissionType"], "view")

        # Failure 1: Update permission for a user/summary pair that doesn't have permission yet
        self.run_test_case(
            self.db_manager.update_permission,
            (TestDbManager.setup_summary2_id, TestDbManager.setup_user3_id, "edit"),
            False,
            "Failure Case 1: Update Non-existent Permission",
        )

    def test_10_link_handling(self):
        logging.info(
            "\n--- Testing Link Handling (_extract, _save, _update, _delete via summary ops) ---"
        )

        # --- Setup for Link Tests ---
        # Summary 1 (S1) exists (owner U1)
        # Summary 2 (S2) exists (owner U2)
        # Create Summary 3 (S3) owned by U1, which will link to S1
        content_s3 = f"This summary links to S1.\n###link {TEST_SUMMARY_1_TITLE}\nEnd of content."
        # Use a class variable to store the ID so it can be cleaned up in tearDownClass
        TestDbManager.setup_summary3_id = self.db_manager.insert_summary(
            TEST_SUMMARY_3_TITLE, content_s3, TestDbManager.setup_user1_id, "Calibri"
        )
        self.assertGreater(
            TestDbManager.setup_summary3_id,
            0,
            "Failed to create summary 3 for link test",
        )

        # Check if link was created S3 -> S1
        self.db_manager.cursor.execute(
            "SELECT target_summary_id FROM links WHERE source_summary_id = %s",
            (TestDbManager.setup_summary3_id,),
        )
        link_target = self.db_manager.cursor.fetchone()
        self.assertIsNotNone(link_target, "Link S3->S1 not created during insert")
        self.assertEqual(
            link_target["target_summary_id"],
            TestDbManager.setup_summary1_id,
            "Link S3->S1 points to wrong target",
        )
        logging.info("Link Handling - Setup: Insert with link PASSED - GREEN")
        self.results["total"] += 1
        self.results["passed"] += 1  # Manual count for setup check

        # --- Test Cases ---
        # Success 1: Update S3 to link to S2 instead of S1 (tests _update_links via save_summary)
        content_s3_updated = f"This summary now links to S2.\n###link {TEST_SUMMARY_2_TITLE}\nMore content."
        self.run_test_case(
            self.db_manager.save_summary,
            (TestDbManager.setup_summary3_id, content_s3_updated),
            True,
            "Success Case 1: Update summary content and link (S3->S2)",
        )
        # Verify link S3->S1 is gone, S3->S2 exists
        self.db_manager.cursor.execute(
            "SELECT target_summary_id FROM links WHERE source_summary_id = %s",
            (TestDbManager.setup_summary3_id,),
        )
        link_targets = self.db_manager.cursor.fetchall()
        self.assertEqual(len(link_targets), 1, "Should be exactly one link from S3")
        self.assertEqual(
            link_targets[0]["target_summary_id"],
            TestDbManager.setup_summary2_id,
            "Link S3->S2 points to wrong target after update",
        )

        # Success 2: Update S3 to have no links (tests _update_links clearing links)
        content_s3_no_links = "This summary has no links now."
        self.run_test_case(
            self.db_manager.save_summary,
            (TestDbManager.setup_summary3_id, content_s3_no_links),
            True,
            "Success Case 2: Update summary content removing links",
        )
        # Verify no links from S3
        self.db_manager.cursor.execute(
            "SELECT target_summary_id FROM links WHERE source_summary_id = %s",
            (TestDbManager.setup_summary3_id,),
        )
        link_targets = self.db_manager.cursor.fetchall()
        self.assertEqual(len(link_targets), 0, "Links should be removed from S3")

        # Failure 1: Insert a summary linking to a non-existent title (tests _extract finding no ID)
        title_fail_link = f"Link Fail Insert {RUN_ID}"
        content_fail = "Link to nowhere.\n###link NonExistentLinkTitle\nEnd."
        sid_fail = self.db_manager.insert_summary(
            title_fail_link, content_fail, TestDbManager.setup_user1_id, "Comic Sans"
        )
        self.results["total"] += 1
        if sid_fail > 0:  # Expect summary creation to succeed, but link ignored
            logging.info(
                f"Link Handling - Failure Case 1: Insert with non-existent link: PASSED (Summary created SID: {sid_fail}, link ignored as expected) - GREEN"
            )
            self.results["passed"] += 1
            self.assertTrue(True)
            # Verify no link was actually created
            self.db_manager.cursor.execute(
                "SELECT 1 FROM links WHERE source_summary_id = %s", (sid_fail,)
            )
            self.assertIsNone(
                self.db_manager.cursor.fetchone(),
                "Link should not have been created for non-existent target",
            )
            # Cleanup this summary
            self.db_manager.delete_summary(sid_fail)
        else:
            logging.error(
                f"Link Handling - Failure Case 1: Insert with non-existent link: FAILED (Summary insertion failed unexpectedly, SID: {sid_fail}) - RED"
            )
            self.results["failed"] += 1
            self.fail(
                "Summary insertion failed when it should have succeeded but ignored the bad link."
            )

    def test_11_save_summary(self):
        logging.info("\n--- Testing save_summary ---")
        # Success 1: Update content of summary 1
        new_content_1 = f"Updated content for summary 1 - {RUN_ID}"
        self.run_test_case(
            self.db_manager.save_summary,
            (TestDbManager.setup_summary1_id, new_content_1),
            True,
            "Success Case 1: Update Content",
        )
        # Verify content updated in file
        summary1 = self.db_manager.get_summary(TestDbManager.setup_summary1_id)
        self.assertEqual(summary1.content, new_content_1)
        # Success 2: Update content of summary 2 including a link (implicitly tested in test_10_link_handling)
        # Add another simple content update test here for completeness
        new_content_2 = f"Another update for summary 2 - {RUN_ID}"
        self.run_test_case(
            self.db_manager.save_summary,
            (TestDbManager.setup_summary2_id, new_content_2),
            True,
            "Success Case 2: Update Content Again",
        )
        summary2 = self.db_manager.get_summary(TestDbManager.setup_summary2_id)
        self.assertEqual(summary2.content, new_content_2)
        # Failure 1: Try to save content for a non-existent summary ID
        self.run_test_case(
            self.db_manager.save_summary,
            (999999, "Content for non-existent summary"),
            False,
            "Failure Case 1: Non-existent Summary ID",
        )

    def test_12_update_summary(self):
        logging.info("\n--- Testing update_summary ---")
        # Success 1: Update font of summary 1
        new_font_1 = f"Verdana {RUN_ID}"
        self.run_test_case(
            self.db_manager.update_summary,
            (TestDbManager.setup_summary1_id, None, new_font_1),
            True,
            "Success Case 1: Update Font Only",
        )
        summary1 = self.db_manager.get_summary(TestDbManager.setup_summary1_id)
        self.assertEqual(summary1.font, new_font_1)
        # Success 2: Update content and font of summary 2
        new_content_2 = f"Updated via update_summary {RUN_ID}"
        new_font_2 = f"Courier New {RUN_ID}"
        self.run_test_case(
            self.db_manager.update_summary,
            (TestDbManager.setup_summary2_id, new_content_2, new_font_2),
            True,
            "Success Case 2: Update Content and Font",
        )
        summary2 = self.db_manager.get_summary(TestDbManager.setup_summary2_id)
        self.assertEqual(summary2.content, new_content_2)
        self.assertEqual(summary2.font, new_font_2)
        # Failure 1: Try to update a non-existent summary ID
        self.run_test_case(
            self.db_manager.update_summary,
            (999999, "Content", "Font"),
            False,
            "Failure Case 1: Non-existent Summary ID",
        )

    def test_13_delete_summary(self):
        logging.info("\n--- Testing delete_summary ---")
        # Setup: Create a temporary summary to delete
        del_title = f"To Be Deleted {RUN_ID}"
        del_content = "Delete me."
        del_sid = self.db_manager.insert_summary(
            del_title, del_content, TestDbManager.setup_user1_id, "DeleteFont"
        )
        self.assertGreater(
            del_sid, 0, "Setup failed: Could not create summary for deletion test"
        )
        del_filepath = self.db_manager.get_summary(
            del_sid
        ).path_to_summary  # Get path for verification later
        # Also create a link pointing to it from S1 (if S1 still exists)
        if TestDbManager.setup_summary1_id > 0:
            s1_content_link_del = f"{TEST_SUMMARY_CONTENT}\n###link {del_title}\n"
            self.db_manager.save_summary(
                TestDbManager.setup_summary1_id, s1_content_link_del
            )
            # Verify link exists S1 -> del_sid
            self.db_manager.cursor.execute(
                "SELECT 1 FROM links WHERE source_summary_id = %s AND target_summary_id = %s",
                (TestDbManager.setup_summary1_id, del_sid),
            )
            self.assertIsNotNone(
                self.db_manager.cursor.fetchone(),
                "Setup failed: Link S1 -> del_sid not created",
            )

        # Success 1: Delete the temporary summary
        self.run_test_case(
            self.db_manager.delete_summary,
            (del_sid,),
            True,
            "Success Case 1: Delete Existing Summary",
        )
        # Verify it's gone from DB
        self.assertIsNone(
            self.db_manager.get_summary(del_sid), "Summary should be null after delete"
        )
        # Verify file is gone
        self.assertFalse(os.path.exists(del_filepath), "Summary file should be deleted")
        # Verify link S1 -> del_sid is gone (tested via _delete_links called by delete_summary)
        self.db_manager.cursor.execute(
            "SELECT 1 FROM links WHERE target_summary_id = %s", (del_sid,)
        )
        self.assertIsNone(
            self.db_manager.cursor.fetchone(),
            "Incoming link to deleted summary should be gone",
        )
        #
        # # Success 2: Delete another summary (use S2 created in setup, if it wasn't deleted yet)
        if TestDbManager.setup_summary2_id > 0:
            s2_filepath = self.db_manager.get_summary(
                TestDbManager.setup_summary2_id
            ).path_to_summary  # Get path before delete
            self.run_test_case(
                self.db_manager.delete_summary,
                (TestDbManager.setup_summary2_id,),
                True,
                "Success Case 2: Delete Another Existing Summary (S2)",
            )
            self.assertIsNone(
                self.db_manager.get_summary(TestDbManager.setup_summary2_id)
            )
            if s2_filepath:  # Check path deletion only if path existed
                self.assertFalse(os.path.exists(s2_filepath))
            #     # Mark S2 as deleted so tearDown doesn't try again
            TestDbManager.setup_summary2_id = -1
        else:
            logging.warning(
                "Skipping delete_summary Success Case 2: Summary S2 already deleted."
            )
            self.results["total"] += 1
            self.results["passed"] += 1  # Count skipped as passed
        #
        # # Failure 1: Delete a non-existent summary ID
        self.run_test_case(
            self.db_manager.delete_summary,
            (999998,),
            False,
            "Failure Case 1: Delete Non-existent Summary ID",
        )

        # Restore S1 content (remove link to deleted summary) if S1 still exists
        if TestDbManager.setup_summary1_id > 0:
            self.db_manager.save_summary(
                TestDbManager.setup_summary1_id, TEST_SUMMARY_CONTENT
            )

    def test_14_insert_event(self):
        logging.info("\n--- Testing insert_event ---")
        now_iso = datetime.datetime.now().isoformat(sep=" ", timespec="seconds")
        # Success 1: Insert event for user 1
        self.run_test_case(
            self.db_manager.insert_event,
            (TestDbManager.setup_user1_id, f"Insert Event 1 {RUN_ID}", now_iso),
            True,
            "Success Case 1: Valid Event User 1",
        )
        # Success 2: Insert event for user 2
        self.run_test_case(
            self.db_manager.insert_event,
            (TestDbManager.setup_user2_id, f"Insert Event 2 {RUN_ID}", now_iso),
            True,
            "Success Case 2: Valid Event User 2",
        )
        # Failure 1: Insert event for non-existent user
        self.run_test_case(
            self.db_manager.insert_event,
            (99999, f"Fail Event {RUN_ID}", now_iso),
            False,
            "Failure Case 1: Non-existent User ID",
        )
        # Failure 2: Insert event with invalid date format
        self.run_test_case(
            self.db_manager.insert_event,
            (TestDbManager.setup_user1_id, f"Fail Date Event {RUN_ID}", "invalid-date"),
            False,
            "Failure Case 2: Invalid Date Format",
        )

    def test_15_get_events(self):
        logging.info("\n--- Testing get_events ---")
        # Success 1: Get events for user 1 (should have at least 2 from setup + 1 from test_14)
        # Count existing events before test_14 added one
        initial_events = self.db_manager.get_events(TestDbManager.setup_user1_id)
        min_expected_count = len(initial_events)

        events1 = self.run_test_case(
            self.db_manager.get_events,
            (TestDbManager.setup_user1_id,),
            True,
            "Success Case 1: Get Events User 1",
        )
        self.assertIsInstance(events1, list)
        # Allow for events being deleted in other tests if run out of order, check >= original count
        self.assertGreaterEqual(
            len(events1),
            min_expected_count - 2,
            f"Expected at least {min_expected_count - 2} events for user 1",
        )

        # Success 2: Get events for user 3 (should be empty initially)
        events3 = self.run_test_case(
            self.db_manager.get_events,
            (TestDbManager.setup_user3_id,),
            True,
            "Success Case 2: Get Events User 3 (Empty)",
        )  # Expect success returning empty list
        self.assertIsInstance(events3, list)
        self.assertEqual(len(events3), 0, "Expected 0 events for user 3")

        # Failure 1: Technically cannot fail unless DB connection breaks. Test with valid user ID expected to return list.
        logging.info(
            "get_events - Failure Case 1: N/A (Function returns [] for no events or errors)"
        )
        self.results["total"] += 1
        self.results["passed"] += 1  # Count N/A case as passed

    def test_16_update_event(self):
        logging.info("\n--- Testing update_event ---")
        # Check if event 1 exists before trying to update
        if TestDbManager.setup_event1_id != -1:
            new_title = f"Updated Event 1 {RUN_ID}"
            new_date = (datetime.datetime.now() + datetime.timedelta(days=5)).isoformat(
                sep=" ", timespec="seconds"
            )
            # Success 1: Update event 1 belonging to user 1
            self.run_test_case(
                self.db_manager.update_event,
                (
                    TestDbManager.setup_event1_id,
                    # TestDbManager.setup_user1_id,
                    new_title,
                    new_date,
                ),
                True,
                "Success Case 1: Update Own Event",
            )
            # Verify update
            events = self.db_manager.get_events(TestDbManager.setup_user1_id)
            event1 = next(
                (e for e in events if e["id"] == TestDbManager.setup_event1_id), None
            )
            self.assertIsNotNone(event1)
            self.assertEqual(event1["event_title"], new_title)
        else:
            logging.warning(
                "Skipping update_event Success Case 1: Event 1 ID not available (likely deleted)."
            )
            self.results["total"] += 1
            self.results["passed"] += 1

        # Check if event 2 exists before trying to update
        if TestDbManager.setup_event2_id != -1:
            new_title_2 = f"Updated Event 2 {RUN_ID}"
            new_date_2 = (
                datetime.datetime.now() + datetime.timedelta(days=6)
            ).isoformat(sep=" ", timespec="seconds")
            self.run_test_case(
                self.db_manager.update_event,
                (
                    TestDbManager.setup_event2_id,
                    # TestDbManager.setup_user1_id,
                    new_title_2,
                    new_date_2,
                ),
                True,
                "Success Case 2: Update Another Own Event",
            )
        else:
            logging.warning(
                "Skipping update_event Success Case 2: Event 2 ID not available (likely deleted)."
            )
            self.results["total"] += 1
            self.results["passed"] += 1

        # Failure 1: Try to update event 1 as user 2 (wrong user)
        if TestDbManager.setup_event1_id != -1:
            fail_date = datetime.datetime.now().isoformat(sep=" ", timespec="seconds")
            self.run_test_case(
                self.db_manager.update_event,
                (
                    TestDbManager.setup_event1_id,
                    # TestDbManager.setup_user2_id,
                    "Hack attempt",
                    fail_date,
                ),
                False,
                "Failure Case 1: Update Event as Wrong User",
            )
        else:
            logging.warning(
                "Skipping update_event Failure Case 1: Event 1 ID not available (likely deleted)."
            )
            self.results["total"] += 1
            self.results["passed"] += 1

    def test_17_delete_event(self):
        logging.info("\n--- Testing delete_event ---")
        # Setup: Create a temporary event for user 2 to delete
        temp_event_title = f"Event to Delete {RUN_ID}"
        temp_event_time = datetime.datetime.now().isoformat(sep=" ", timespec="seconds")
        self.db_manager.insert_event(
            TestDbManager.setup_user2_id, temp_event_title, temp_event_time
        )
        events_u2 = self.db_manager.get_events(TestDbManager.setup_user2_id)
        temp_event_id = next(
            (e["id"] for e in events_u2 if e["event_title"] == temp_event_title), -1
        )
        self.assertGreater(
            temp_event_id, 0, "Setup failed: Could not create event for deletion test"
        )

        # Success 1: User 2 deletes their own temporary event
        self.run_test_case(
            self.db_manager.delete_event,
            (temp_event_id, TestDbManager.setup_user2_id),
            True,
            "Success Case 1: Delete Own Event",
        )
        # Verify deletion
        events_u2_after = self.db_manager.get_events(TestDbManager.setup_user2_id)
        self.assertIsNone(
            next((e for e in events_u2_after if e["id"] == temp_event_id), None),
            "Event should be deleted",
        )

        # Success 2: User 1 deletes their own event (event 2 from setup, if exists)
        if TestDbManager.setup_event2_id != -1:
            self.run_test_case(
                self.db_manager.delete_event,
                (TestDbManager.setup_event2_id, TestDbManager.setup_user1_id),
                True,
                "Success Case 2: Delete Own Event (Setup Event 2)",
            )
            TestDbManager.setup_event2_id = -1  # Mark as deleted
        else:
            logging.warning(
                "Skipping delete_event Success Case 2: Event 2 ID not available (likely deleted)."
            )
            self.results["total"] += 1
            self.results["passed"] += 1

        # Failure 1: User 2 tries to delete User 1's event (event 1 from setup, if exists)
        if TestDbManager.setup_event1_id != -1:
            self.run_test_case(
                self.db_manager.delete_event,
                (TestDbManager.setup_event1_id, TestDbManager.setup_user2_id),
                False,
                "Failure Case 1: Delete Event as Wrong User",
            )
        else:
            logging.warning(
                "Skipping delete_event Failure Case 1: Event 1 ID not available (likely deleted)."
            )
            self.results["total"] += 1
            self.results["passed"] += 1

    def test_18_get_summary_share_link(self):
        logging.info("\n--- Testing get_summary_share_link ---")
        # Success 1: Get share link for summary 1 (if exists)
        if TestDbManager.setup_summary1_id > 0:
            link1 = self.run_test_case(
                self.db_manager.get_summary_share_link,
                (TestDbManager.setup_summary1_id,),
                True,
                "Success Case 1: Get Link for Summary 1",
            )
            self.assertEqual(link1, TEST_SUMMARY_1_TITLE)
        else:
            logging.warning(
                "Skipping get_summary_share_link Success Case 1: Summary 1 ID not available."
            )
            self.results["total"] += 1
            self.results["passed"] += 1

        # Success 2: Get share link for summary 3 (created in link test, if exists)
        if TestDbManager.setup_summary3_id > 0:  # Check if summary 3 exists
            link3 = self.run_test_case(
                self.db_manager.get_summary_share_link,
                (TestDbManager.setup_summary3_id,),
                True,
                "Success Case 2: Get Link for Summary 3",
            )
            self.assertEqual(link3, TEST_SUMMARY_3_TITLE)
        else:
            logging.warning(
                "Skipping get_summary_share_link Success Case 2: Summary 3 ID not available."
            )
            self.results["total"] += 1
            self.results["passed"] += 1

        # Failure 1: Get share link for non-existent summary ID
        self.run_test_case(
            self.db_manager.get_summary_share_link,
            (999999,),
            False,
            "Failure Case 1: Non-existent Summary ID",
        )

    def test_19_get_summary_times(self):
        logging.info("\n--- Testing get_summary_times ---")
        # Success 1: Get times for summary 1 (if exists)
        if TestDbManager.setup_summary1_id > 0:
            times1 = self.run_test_case(
                self.db_manager.get_summary_times,
                (TestDbManager.setup_summary1_id,),
                True,
                "Success Case 1: Get Times for Summary 1",
            )
            self.assertIsInstance(times1, list)
            self.assertEqual(len(times1), 2)
            self.assertIsInstance(
                times1[0], datetime.datetime
            )  # createTime should exist
            # updateTime might be None initially or datetime after updates
            self.assertTrue(
                times1[1] is None or isinstance(times1[1], datetime.datetime)
            )
        else:
            logging.warning(
                "Skipping get_summary_times Success Case 1: Summary 1 ID not available."
            )
            self.results["total"] += 1
            self.results["passed"] += 1

        # Success 2: Get times for summary 3 (if exists)
        if TestDbManager.setup_summary3_id > 0:
            times3 = self.run_test_case(
                self.db_manager.get_summary_times,
                (TestDbManager.setup_summary3_id,),
                True,
                "Success Case 2: Get Times for Summary 3",
            )
            self.assertIsInstance(times3, list)
            self.assertEqual(len(times3), 2)
            self.assertIsInstance(times3[0], datetime.datetime)
        else:
            logging.warning(
                "Skipping get_summary_times Success Case 2: Summary 3 ID not available."
            )
            self.results["total"] += 1
            self.results["passed"] += 1

        # Failure 1: Get times for non-existent summary ID
        self.run_test_case(
            self.db_manager.get_summary_times,
            (999999,),
            False,
            "Failure Case 1: Non-existent Summary ID",
        )

    def test_20_get_all_by_user(self):
        logging.info("\n--- Testing get_all_by_user ---")
        # Success 1: Get summaries for user 1 (should have S1 and maybe S3)
        summaries1 = self.run_test_case(
            self.db_manager.get_all_by_user,
            (TestDbManager.setup_user1_id,),
            True,
            "Success Case 1: Get Summaries User 1",
        )
        self.assertIsInstance(summaries1, list)
        expected_s1_count = (1 if TestDbManager.setup_summary1_id > 0 else 0) + (
            1 if TestDbManager.setup_summary3_id > 0 else 0
        )
        self.assertEqual(
            len(summaries1),
            expected_s1_count,
            f"Expected {expected_s1_count} summaries for user 1",
        )
        if TestDbManager.setup_summary1_id > 0:
            self.assertTrue(
                any(s.id == TestDbManager.setup_summary1_id for s in summaries1)
            )
        if TestDbManager.setup_summary3_id > 0:
            self.assertTrue(
                any(s.id == TestDbManager.setup_summary3_id for s in summaries1)
            )

        # Success 2: Get summaries for user 2 (should have S2 if not deleted, else 0)
        summaries2 = self.run_test_case(
            self.db_manager.get_all_by_user,
            (TestDbManager.setup_user2_id,),
            True,
            "Success Case 2: Get Summaries User 2",
        )
        self.assertIsInstance(summaries2, list)
        expected_s2_count = (
            1 if TestDbManager.setup_summary2_id > 0 else 0
        )  # Check if S2 was deleted
        self.assertEqual(
            len(summaries2),
            expected_s2_count,
            f"Expected {expected_s2_count} summaries for user 2",
        )

        # Failure 1: N/A (Function returns [] for no summaries or errors)
        logging.info("get_all_by_user - Failure Case 1: N/A (Returns [] )")
        self.results["total"] += 1
        self.results["passed"] += 1

    def test_21_get_all_user_can_access(self):
        logging.info("\n--- Testing get_all_user_can_access ---")
        # Setup: Ensure U1 shared S1 with U2 (view/edit) if S1 exists.
        if TestDbManager.setup_summary1_id > 0:
            self.db_manager.share_summary(
                TestDbManager.setup_summary1_id,
                TestDbManager.setup_user1_id,
                TestDbManager.setup_user2_id,
                "view",
            )

        # Success 1: Get summaries User 1 can access (Owned: S1?, S3?)
        access1 = self.run_test_case(
            self.db_manager.get_all_user_can_access,
            (TestDbManager.setup_user1_id,),
            True,
            "Success Case 1: Access for User 1 (Owner)",
        )
        self.assertIsInstance(access1, list)
        expected_s1_count = (1 if TestDbManager.setup_summary1_id > 0 else 0) + (
            1 if TestDbManager.setup_summary3_id > 0 else 0
        )
        self.assertEqual(
            len(access1),
            expected_s1_count,
            f"Expected {expected_s1_count} summaries for user 1",
        )
        if TestDbManager.setup_summary1_id > 0:
            self.assertTrue(
                any(s.id == TestDbManager.setup_summary1_id for s in access1)
            )

        # Success 2: Get summaries User 2 can access (Owned: S2?, Shared: S1?)
        access2 = self.run_test_case(
            self.db_manager.get_all_user_can_access,
            (TestDbManager.setup_user2_id,),
            True,
            "Success Case 2: Access for User 2 (Owner+Shared)",
        )
        self.assertIsInstance(access2, list)
        expected_s2_count = (1 if TestDbManager.setup_summary2_id > 0 else 0) + (
            1 if TestDbManager.setup_summary1_id > 0 else 0
        )  # Own S2? + Shared S1?
        self.assertEqual(
            len(access2),
            expected_s2_count,
            f"Expected {expected_s2_count} summaries for user 2",
        )
        if TestDbManager.setup_summary1_id > 0:
            self.assertTrue(
                any(s.id == TestDbManager.setup_summary1_id for s in access2),
                "User 2 should have access to S1",
            )
        if TestDbManager.setup_summary2_id > 0:
            self.assertTrue(
                any(s.id == TestDbManager.setup_summary2_id for s in access2),
                "User 2 should have access to S2",
            )

        # Failure 1: N/A (Function returns [] for no access or errors)
        logging.info("get_all_user_can_access - Failure Case 1: N/A (Returns [])")
        self.results["total"] += 1
        self.results["passed"] += 1

    def test_22_get_graph(self):
        logging.info("\n--- Testing get_graph ---")
        # Setup: Ensure S3 links to S1, and S1 links to S2 for a chain (if they exist)
        if TestDbManager.setup_summary3_id > 0 and TestDbManager.setup_summary1_id > 0:
            content_s3_links_s1 = f"S3 links to S1.\n###link {TEST_SUMMARY_1_TITLE}\n"
            self.db_manager.save_summary(
                TestDbManager.setup_summary3_id, content_s3_links_s1
            )

        if TestDbManager.setup_summary1_id > 0 and TestDbManager.setup_summary2_id > 0:
            content_s1_links_s2 = f"S1 links to S2.\n###link {TEST_SUMMARY_2_TITLE}\n"
            self.db_manager.save_summary(
                TestDbManager.setup_summary1_id, content_s1_links_s2
            )
        elif TestDbManager.setup_summary1_id > 0:  # If S2 was deleted, reset S1 content
            self.db_manager.save_summary(
                TestDbManager.setup_summary1_id, TEST_SUMMARY_CONTENT
            )

        # Success 1: Get graph for S1 (Parent: S3?, Children: S2?)
        if TestDbManager.setup_summary1_id > 0:
            graph1 = self.run_test_case(
                self.db_manager.get_graph,
                (TestDbManager.setup_summary1_id,),
                True,
                "Success Case 1: Graph for Summary 1",
            )
            self.assertIsInstance(graph1, list)
            self.assertGreaterEqual(
                len(graph1), 1
            )  # Should have at least the root node
            root_node_s1 = next(
                (
                    n
                    for n in graph1
                    if n.id == TestDbManager.setup_summary1_id and n.type == "summary"
                ),
                None,
            )
            parent_node_s3 = next(
                (
                    n
                    for n in graph1
                    if n.id == TestDbManager.setup_summary3_id and n.type == "parent"
                ),
                None,
            )
            self.assertIsNotNone(root_node_s1, "Root node for S1 not found in graph")
            if TestDbManager.setup_summary3_id > 0:  # Check parent only if S3 exists
                self.assertIsNotNone(
                    parent_node_s3, "Parent node S3 not found in graph for S1"
                )
            if TestDbManager.setup_summary2_id > 0:  # Check child only if S2 exists
                self.assertTrue(
                    any(
                        child.id == TestDbManager.setup_summary2_id
                        for child in root_node_s1.children
                    ),
                    "Child node S2 not found for S1",
                )
            else:
                self.assertEqual(
                    len(root_node_s1.children),
                    0,
                    "S1 should have no children if S2 deleted",
                )
        else:
            logging.warning(
                "Skipping get_graph Success Case 1: Summary 1 ID not available."
            )
            self.results["total"] += 1
            self.results["passed"] += 1

        # Success 2: Get graph for S3 (Parent: None, Children: S1?)
        if TestDbManager.setup_summary3_id > 0:
            graph3 = self.run_test_case(
                self.db_manager.get_graph,
                (TestDbManager.setup_summary3_id,),
                True,
                "Success Case 2: Graph for Summary 3",
            )
            self.assertIsInstance(graph3, list)
            # Should have the root node S3. If S1 exists, it should be a child. No parents link to S3 in this setup.
            self.assertEqual(
                len(graph3), 1
            )  # Only root node S3 should be returned (no parents)
            root_node_s3 = graph3[0]
            self.assertEqual(root_node_s3.id, TestDbManager.setup_summary3_id)
            self.assertEqual(root_node_s3.type, "summary")
            if TestDbManager.setup_summary1_id > 0:  # Check child only if S1 exists
                self.assertEqual(len(root_node_s3.children), 1)
                self.assertEqual(
                    root_node_s3.children[0].id, TestDbManager.setup_summary1_id
                )
            else:
                self.assertEqual(len(root_node_s3.children), 0)
        else:
            logging.warning(
                "Skipping get_graph Success Case 2: Summary 3 ID not available."
            )
            self.results["total"] += 1
            self.results["passed"] += 1

        # Failure 1: Get graph for non-existent summary ID
        graph_fail = self.run_test_case(
            self.db_manager.get_graph,
            (999999,),
            True,
            "Failure Case 1: Non-existent Summary ID",
        )  # Expects success returning []
        self.assertIsInstance(graph_fail, list)
        self.assertEqual(len(graph_fail), 0)


# --- Test Runner ---
if __name__ == "__main__":
    runner = unittest.TextTestRunner(verbosity=1)
    suite = unittest.TestSuite()

    # Add tests in order using TestLoader to respect the naming convention
    test_loader = unittest.TestLoader()
    # Sort test methods by name (using the 'test_XX_' prefix)
    test_names = sorted(
        [name for name in dir(TestDbManager) if name.startswith("test_")]
    )
    for test_name in test_names:
        suite.addTest(TestDbManager(test_name))

    # Run the tests
    runner.run(suite)
    # The summary report is printed automatically by tearDownClass now


// ----- EventDiag.py -----
import datetime
import wx
import wx.adv  # Needed for DatePickerCtrl and TimePickerCtrl
import os
import pickle
import base64  # Needed for encoding/decoding event data for network
import threading  # Needed for GCal import
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build

# Assume net object has methods:
# net.send_message(message)
# net.build_message(command, params)
# net.add_handler(command, handler_function)
# Assume parent object might be needed for context or accessing net if not passed directly
# For standalone testing, you might need dummy net/parent classes.
HEIGHT = 6


class EventsDialog(wx.Dialog):
    def __init__(self, events, parent, net, debug=False):  # Added debug flag
        super().__init__(
            None, title="Your Events Calendar", size=(800, 800)
        )  # Increased height for logs
        self.events = events
        self.parent = parent  # Keep reference if needed elsewhere
        self.net = net
        self.debug = debug  # Store debug flag
        self.log_messages = []  # Initialize log storage
        self.log_display = None  # <<<< MOVE THIS LINE UP

        # --- Now it's safe to log ---
        self.log_event("Initializing EventsDialog.")

        self.delete_buttons = []  # Store references to delete buttons
        self.credentials = None
        self.service = None

        # Calendar navigation variables
        now = datetime.datetime.now()
        self.current_month = now.month
        self.current_year = now.year
        self.selected_date = now.date()
        self.day_buttons = []  # Buttons/Panels representing days
        self.events_by_date = {}  # Cache events grouped by date

        # self.log_display = None # <<<< REMOVE FROM HERE (or comment out)

        # Register network handlers (comments remain the same)
        # ...
        self.organize_events_by_date()
        self.setup_ui()  # Initialize UI
        self.log_event(
            "UI Setup complete."
        )  # This call is fine as setup_ui might assign the TextCtrl
        self.update_events_for_selected_date()

    # def on_event_success(self,parent,*params,net):
    #     # add the event to list and re render
    #     self.log_event("Event successfully added.")
    #     self.events.append(params[0]) # Assuming params[0] is the new event
    #     self.organize_events_by_date() # Reorganize events by date
    #     self.update_events_for_selected_date() # Update the event list for the selected 2025-04-29
    #     self.update_calendar_grid(self.calendar_section) # Update the calendar grid
    #     self.update_log_display() # Update the log display if it exists
    #     self.log_event("Event successfully added and UI updated.")
    # #    self.net.add_handler("EVENT_SUCCESS", self.on_event_success) # Register the handler for event success
    #
    def log_event(self, message):
        """Adds a timestamped message to the log."""
        if not self.debug:
            return
        now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        log_entry = f"{now} - {message}"
        self.log_messages.append(log_entry)
        # Keep log concise (e.g., last 100 entries)
        if len(self.log_messages) > 100:
            self.log_messages.pop(0)
        self.update_log_display()  # Update the GUI

    def update_log_display(self):
        """Updates the log display TextCtrl if it exists and debug is True."""
        if self.debug and self.log_display:
            # Use CallAfter for thread safety if logs can be generated from other threads
            wx.CallAfter(self.log_display.SetValue, "\n".join(self.log_messages))
            wx.CallAfter(
                self.log_display.ShowPosition, self.log_display.GetLastPosition()
            )

    def setup_ui(self):
        """Setup the UI components and refresh the dialog when called."""
        self.log_event("Setting up UI...")
        # Clear existing UI
        self.DestroyChildren()  # More robust than Clear() for complex layouts

        # Main panel and sizer
        panel = wx.Panel(self)
        main_sizer = wx.BoxSizer(wx.VERTICAL)

        # --- Top Buttons Row ---
        top_button_sizer = wx.BoxSizer(wx.HORIZONTAL)

        # Add New Event button
        add_event_button = wx.Button(panel, label="Add New Event")
        add_event_button.Bind(wx.EVT_BUTTON, self.on_add_event)

        # Google Calendar import button
        gcal_button = wx.Button(panel, label="Import from Google Calendar")
        gcal_button.Bind(wx.EVT_BUTTON, self.on_import_gcal)

        # Save to Server button
        # save_button = wx.Button(panel, label="Save Events to Server")
        # save_button.Bind(wx.EVT_BUTTON, self.on_save_to_server)
        #
        top_button_sizer.Add(add_event_button, flag=wx.RIGHT, border=10)
        top_button_sizer.Add(gcal_button, flag=wx.RIGHT, border=10)
        # top_button_sizer.Add(save_button)
        main_sizer.Add(top_button_sizer, flag=wx.EXPAND | wx.ALL, border=10)

        # --- Calendar Section ---
        calendar_section = wx.StaticBox(panel, label="Calendar View")
        self.calendar_section = calendar_section
        calendar_sizer = wx.StaticBoxSizer(calendar_section, wx.VERTICAL)
        self.calendar_sizer = calendar_sizer
        # Month navigation
        month_nav_sizer = wx.BoxSizer(wx.HORIZONTAL)
        prev_month_btn = wx.Button(panel, label="", size=(30, -1))
        next_month_btn = wx.Button(panel, label="", size=(30, -1))

        month_names = [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ]
        self.month_year_label = wx.StaticText(
            panel, label=f"{month_names[self.current_month-1]} {self.current_year}"
        )
        self.month_year_label.SetFont(
            wx.Font(12, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD)
        )

        month_nav_sizer.Add(prev_month_btn, flag=wx.RIGHT, border=5)
        month_nav_sizer.Add(self.month_year_label, proportion=1, flag=wx.ALIGN_CENTER)
        month_nav_sizer.Add(next_month_btn, flag=wx.LEFT, border=5)
        calendar_sizer.Add(month_nav_sizer, flag=wx.EXPAND | wx.ALL, border=10)

        prev_month_btn.Bind(wx.EVT_BUTTON, self.on_prev_month)
        next_month_btn.Bind(wx.EVT_BUTTON, self.on_next_month)

        # Day names row
        days_sizer = wx.GridSizer(rows=1, cols=7, hgap=1, vgap=1)  # Use rows=1
        day_names = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        for day_name in day_names:
            day_label = wx.StaticText(panel, label=day_name, style=wx.ALIGN_CENTER)
            day_label.SetFont(
                wx.Font(
                    10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD
                )
            )
            day_label.SetBackgroundColour(wx.Colour(220, 220, 220))
            days_sizer.Add(day_label, flag=wx.EXPAND | wx.ALL, border=1)
        calendar_sizer.Add(days_sizer, flag=wx.EXPAND | wx.LEFT | wx.RIGHT, border=10)

        # Calendar grid
        self.calendar_grid = wx.GridSizer(rows=HEIGHT, cols=7, hgap=1, vgap=1)
        self.update_calendar_grid(panel)  # Pass panel for creating children
        calendar_sizer.Add(self.calendar_grid, flag=wx.EXPAND | wx.ALL, border=5)
        main_sizer.Add(
            calendar_sizer, proportion=1, flag=wx.EXPAND | wx.ALL, border=5
        )  # Allow calendar to expand vertically

        # --- Events for Selected Date Section ---
        events_section = wx.StaticBox(
            panel, label=f"Events for {self.selected_date.strftime('%Y-%m-%d')}"
        )
        events_sizer = wx.StaticBoxSizer(events_section, wx.VERTICAL)
        self.events_static_box = events_section
        events_list_sizer = wx.BoxSizer(wx.HORIZONTAL)

        self.events_list = wx.ListCtrl(
            panel,
            style=wx.LC_REPORT | wx.LC_SINGLE_SEL | wx.LC_VRULES,
            size=(250 + 80 + 150 + 70 + 5 * 4, 300),
        )
        self.events_list.InsertColumn(0, "Title", width=250)
        self.events_list.InsertColumn(1, "Time", width=80)
        self.events_list.InsertColumn(2, "Created", width=150)
        self.events_list.InsertColumn(3, "Past Due", width=70)
        print("Size: ", self.events_list.GetSize())
        # Panel to hold delete buttons aligned with list items
        self.buttons_panel = wx.Panel(panel)
        self.buttons_sizer = wx.BoxSizer(wx.VERTICAL)
        self.buttons_panel.SetSizer(self.buttons_sizer)

        events_list_sizer.Add(
            self.events_list, proportion=1, flag=wx.EXPAND | wx.RIGHT, border=5
        )
        events_list_sizer.Add(
            self.buttons_panel, flag=wx.ALIGN_TOP
        )  # Buttons align top
        events_sizer.Add(
            events_list_sizer, proportion=1, flag=wx.EXPAND | wx.ALL, border=5
        )
        main_sizer.Add(
            events_sizer, proportion=1, flag=wx.EXPAND | wx.ALL, border=10
        )  # Allow event list to expand

        # --- Log Display Section (Conditional) ---
        if self.debug:
            log_section = wx.StaticBox(panel, label="Event Log")
            log_sizer = wx.StaticBoxSizer(log_section, wx.VERTICAL)
            self.log_display = wx.TextCtrl(
                panel, style=wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_DONTWRAP
            )
            self.log_display.SetMinSize((-1, 100))  # Ensure minimum height for log
            log_sizer.Add(
                self.log_display, proportion=1, flag=wx.EXPAND | wx.ALL, border=5
            )
            main_sizer.Add(
                log_sizer, proportion=0, flag=wx.EXPAND | wx.ALL, border=10
            )  # Log section doesn't expand by default

        # --- Close Button ---
        bottom_sizer = wx.BoxSizer(wx.HORIZONTAL)
        close_button = wx.Button(panel, label="Close")
        close_button.Bind(wx.EVT_BUTTON, self.on_close)
        bottom_sizer.AddStretchSpacer()
        bottom_sizer.Add(close_button, flag=wx.ALIGN_CENTER)
        bottom_sizer.AddStretchSpacer()
        main_sizer.Add(
            bottom_sizer, flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.BOTTOM, border=10
        )

        panel.SetSizer(main_sizer)

        # Initial data population
        self.organize_events_by_date()
        self.update_events_for_selected_date()
        self.update_log_display()  # Show initial logs

        # Force layout calculation
        self.Layout()
        self.Fit()  # Adjust dialog size to fit content if needed
        self.Centre()  # Center the dialog on screen
        self.log_event("UI setup and layout complete.")
        self.update_calendar_grid(panel)

    def organize_events_by_date(self):
        """Group events by their date for easier access."""
        self.log_event("Organizing events by date.")
        self.events_by_date = {}
        if not self.events:  # Handle empty events list
            self.log_event("No events to organize.")
            return
        for event in self.events:
            # Ensure event_date is a datetime object
            if isinstance(event.get("event_date"), datetime.datetime):
                event_date = event["event_date"].date()
                if event_date not in self.events_by_date:
                    self.events_by_date[event_date] = []
                self.events_by_date[event_date].append(event)
            else:
                self.log_event(
                    f"Warning: Event '{event.get('event_title')}' has invalid date format: {event.get('event_date')}"
                )
        self.log_event(f"Organized events into {len(self.events_by_date)} date groups.")

    def update_calendar_grid(self, panel):
        """Update the calendar grid with days for the current month/year."""
        self.log_event(
            f"Updating calendar grid for {self.current_month}/{self.current_year}."
        )
        self.calendar_grid.Clear(delete_windows=True)
        self.day_buttons = []

        # --- Define Colors ---
        COLOR_SELECTED = wx.Colour(255, 215, 100)  # Gold
        COLOR_TODAY = wx.Colour(200, 230, 255)  # Light blue
        COLOR_PAST_EVENT = wx.Colour(255, 200, 200)  # Light red
        COLOR_FUTURE_EVENT = wx.Colour(200, 255, 200)  # Light green
        COLOR_DEFAULT_BG = wx.NullColour  # System default background
        COLOR_EMPTY_CELL = wx.Colour(240, 240, 240)  # Grey for empty cells
        COLOR_EVENT_INDICATOR = wx.Colour(0, 100, 0)  # Dark green for dot

        try:
            # Calculate first and last day of month safely
            first_day = datetime.date(self.current_year, self.current_month, 1)

            # Calculate last day more safely
            if self.current_month == 12:
                next_month = datetime.date(self.current_year + 1, 1, 1)
            else:
                next_month = datetime.date(self.current_year, self.current_month + 1, 1)

            last_day = next_month - datetime.timedelta(days=1)
            days_in_month = last_day.day

            self.log_event(
                f"Month has {days_in_month} days, starts on {first_day.strftime('%A')}"
            )
        except ValueError as e:
            # Handle potential invalid date combinations
            self.log_event(f"Error calculating dates: {e}. Resetting to current month.")
            self.current_month = datetime.datetime.now().month
            self.current_year = datetime.datetime.now().year

            # Recalculate after reset
            first_day = datetime.date(self.current_year, self.current_month, 1)
            if self.current_month == 12:
                next_month = datetime.date(self.current_year + 1, 1, 1)
            else:
                next_month = datetime.date(self.current_year, self.current_month + 1, 1)

            last_day = next_month - datetime.timedelta(days=1)
            days_in_month = last_day.day

        # Get the weekday of the first day (0=Monday, 6=Sunday)
        first_weekday = first_day.weekday()

        # Add empty cells before the 1st
        for _ in range(first_weekday):
            empty_cell = wx.Panel(panel)
            empty_cell.SetBackgroundColour(COLOR_EMPTY_CELL)
            self.calendar_grid.Add(empty_cell, flag=wx.EXPAND)
            self.day_buttons.append(None)

        # Get current date/time ONCE for comparison
        now_datetime = datetime.datetime.now()
        now_date = now_datetime.date()  # Today's date

        # Add day cells - this is the critical part for showing all days
        for day in range(1, days_in_month + 1):
            current_date = datetime.date(self.current_year, self.current_month, day)
            day_panel = wx.Panel(panel)
            day_sizer = wx.BoxSizer(wx.VERTICAL)

            # Create day label with adequate size
            day_label = wx.StaticText(day_panel, label=str(day), style=wx.ALIGN_LEFT)
            day_label.SetMinSize((20, 15))  # Ensure minimum size for visibility
            day_sizer.Add(day_label, flag=wx.ALL, border=2)

            # --- Determine Date Status & Styling ---
            is_today = current_date == now_date
            is_selected = current_date == self.selected_date
            date_events = self.events_by_date.get(current_date, [])
            has_events = bool(date_events)

            all_past = False
            any_future = False
            tooltip_lines = []

            if has_events:
                all_past = all(
                    e.get("event_date", now_datetime) < now_datetime
                    for e in date_events
                )
                any_future = any(
                    e.get(
                        "event_date", now_datetime - datetime.timedelta(days=1)
                    ).date()
                    >= now_date
                    for e in date_events
                )

                num_events = len(date_events)
                event_plural = "s" if num_events > 1 else ""

                # Create tooltip preview
                tooltip_lines.append(f"{current_date.strftime('%A, %B %d, %Y')}:")
                for event in sorted(date_events, key=lambda e: e.get("event_date")):
                    time_str = (
                        event.get("event_date", "N/A").strftime("%H:%M")
                        if isinstance(event.get("event_date"), datetime.datetime)
                        else "N/A"
                    )
                    tooltip_lines.append(
                        f"- {time_str} {event.get('event_title', 'No Title')}"
                    )
                    if len(tooltip_lines) > 5:  # Limit preview to a few events
                        tooltip_lines.append("...")
                        break

            # Apply initial background color
            bg_color = COLOR_DEFAULT_BG

            # Add event indicator dot BEFORE applying background colors
            if has_events:
                event_indicator = wx.StaticText(day_panel, label="")  # Just a dot
                indicator_font = wx.Font(
                    12, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD
                )
                event_indicator.SetFont(indicator_font)
                event_indicator.SetForegroundColour(COLOR_EVENT_INDICATOR)
                day_sizer.Add(
                    event_indicator, flag=wx.ALIGN_LEFT | wx.LEFT | wx.RIGHT, border=2
                )

                # Color based on event status (show immediately without click)
                if all_past:
                    bg_color = COLOR_PAST_EVENT
                elif any_future:
                    bg_color = COLOR_FUTURE_EVENT

            # Override with Today's color if applicable
            if is_today:
                bg_color = COLOR_TODAY
                day_label.SetFont(
                    wx.Font(
                        10,
                        wx.FONTFAMILY_DEFAULT,
                        wx.FONTSTYLE_NORMAL,
                        wx.FONTWEIGHT_BOLD,
                    )
                )

            # Highest priority: Selected date color
            if is_selected:
                bg_color = COLOR_SELECTED

            # Apply the background color
            day_panel.SetBackgroundColour(bg_color)

            # Finish setting up the day cell
            day_panel.SetSizer(day_sizer)

            # Use lambda with explicit default parameter to avoid late binding issues
            day_panel.Bind(
                wx.EVT_LEFT_DOWN,
                lambda evt, date=current_date: self.on_date_selected(evt, date),
            )

            # Update Tooltip with event preview
            tooltip_text = (
                "\n".join(tooltip_lines)
                if tooltip_lines
                else current_date.strftime("%A, %B %d, %Y")
            )
            day_panel.SetToolTip(tooltip_text)

            self.calendar_grid.Add(day_panel, flag=wx.EXPAND)
            self.day_buttons.append(day_panel)

        # Add empty cells after the last day
        total_cells = HEIGHT * 7
        remaining_cells = total_cells - (first_weekday + days_in_month)
        for _ in range(remaining_cells):
            empty_cell = wx.Panel(panel)
            empty_cell.SetBackgroundColour(COLOR_EMPTY_CELL)
            self.calendar_grid.Add(empty_cell, flag=wx.EXPAND)
            self.day_buttons.append(None)

        # Ensure proper layout
        self.calendar_grid.Layout()
        self.log_event("Calendar grid updated with event highlighting.")

    def on_date_selected(self, event, date):
        """Handle date selection from the calendar with improved responsiveness."""
        self.log_event(f"Date selected: {date}")

        # Store old selection to update only what's needed
        old_date = self.selected_date
        self.selected_date = date

        # --- Update Visual Selection Efficiently ---
        # Only update the two affected dates instead of redrawing entire grid

        # Find old date button and restore its appropriate color
        if old_date:
            old_month = old_date.month
            old_year = old_date.year
            old_day = old_date.day

            # Only try to update if the date was in the current view
            if old_month == self.current_month and old_year == self.current_year:
                # Find the button index for the old date
                first_day = datetime.date(self.current_year, self.current_month, 1)
                first_day_idx = first_day.weekday()
                old_day_idx = first_day_idx + old_day - 1

                if (
                    0 <= old_day_idx < len(self.day_buttons)
                    and self.day_buttons[old_day_idx]
                ):
                    old_panel = self.day_buttons[old_day_idx]

                    # Determine appropriate color for old date
                    now_date = datetime.datetime.now().date()
                    is_today = old_date == now_date
                    date_events = self.events_by_date.get(old_date, [])
                    has_events = bool(date_events)

                    # Default background
                    bg_color = wx.NullColour

                    # Set color based on event status
                    if has_events:
                        now_datetime = datetime.datetime.now()
                        all_past = all(
                            e.get("event_date", now_datetime) < now_datetime
                            for e in date_events
                        )
                        any_future = any(
                            e.get(
                                "event_date", now_datetime - datetime.timedelta(days=1)
                            ).date()
                            >= now_date
                            for e in date_events
                        )

                        if all_past:
                            bg_color = wx.Colour(255, 200, 200)  # Light red
                        elif any_future:
                            bg_color = wx.Colour(200, 255, 200)  # Light green

                    # Override with today's color
                    if is_today:
                        bg_color = wx.Colour(200, 230, 255)  # Light blue

                    # Apply color immediately without full grid redraw
                    old_panel.SetBackgroundColour(bg_color)
                    old_panel.Refresh()

        # Find new date button and highlight it
        if date.month == self.current_month and date.year == self.current_year:
            # Find the button index for the new date
            first_day = datetime.date(self.current_year, self.current_month, 1)
            first_day_idx = first_day.weekday()
            new_day_idx = first_day_idx + date.day - 1

            if (
                0 <= new_day_idx < len(self.day_buttons)
                and self.day_buttons[new_day_idx]
            ):
                new_panel = self.day_buttons[new_day_idx]
                # Highlight selected date
                new_panel.SetBackgroundColour(wx.Colour(255, 215, 100))  # Gold
                new_panel.Refresh()

        # --- Update Events List ---
        # Update the label of the events section
        if hasattr(self, "events_static_box") and self.events_static_box:
            self.events_static_box.SetLabel(
                f"Events for {self.selected_date.strftime('%Y-%m-%d')}"
            )

        # Update the events list without redrawing everything
        self.update_events_for_selected_date()

        # Refresh only what's necessary
        self.events_static_box.Refresh()

    def update_events_for_selected_date(self):
        """Update the events list to show events for the selected date."""
        self.log_event(f"Updating event list for {self.selected_date}.")
        self.events_list.DeleteAllItems()

        # Clear old buttons correctly
        self.buttons_sizer.Clear(delete_windows=True)
        self.delete_buttons = []

        events_on_date = self.events_by_date.get(self.selected_date, [])
        self.log_event(f"Found {len(events_on_date)} events for this date.")

        if events_on_date:
            # Sort events by time
            events_on_date.sort(key=lambda e: e["event_date"])

            now_time = datetime.datetime.now()

            for i, event in enumerate(events_on_date):
                # Check required fields
                event_title = event.get("event_title", "Missing Title")
                event_datetime = event.get("event_date")
                event_createtime = event.get("createTime")
                event_id = event.get("id", None)  # Get ID for delete button

                if event_id is None:
                    self.log_event(f"Warning: Event '{event_title}' is missing an ID.")

                time_str = event_datetime.strftime("%H:%M") if event_datetime else "N/A"
                created_str = (
                    event_createtime.strftime("%Y-%m-%d %H:%M")
                    if event_createtime
                    else "N/A"
                )
                is_past_due = event_datetime < now_time if event_datetime else False

                index = self.events_list.InsertItem(i, event_title)
                self.events_list.SetItem(index, 1, time_str)
                self.events_list.SetItem(index, 2, created_str)
                self.events_list.SetItem(index, 3, str(is_past_due))

                # Highlight past due events
                if is_past_due:
                    item = self.events_list.GetItem(index)
                    item.SetTextColour(wx.RED)
                    self.events_list.SetItem(item)  # Apply the change

                # --- Add Delete Button with proper ID storage ---
                if event_id is not None:
                    # Create delete button with unique ID
                    btn_id = wx.NewId()
                    delete_btn = wx.Button(
                        self.buttons_panel, id=btn_id, label="Delete", size=(70, -1)
                    )

                    # Store event ID as user data
                    delete_btn.event_id = event_id  # Store as an attribute

                    # Bind with explicit reference to the button's event ID
                    delete_btn.Bind(
                        wx.EVT_BUTTON,
                        lambda evt, eid=event_id: self.on_delete_btn(evt, eid),
                    )

                    self.delete_buttons.append(delete_btn)
                    self.buttons_sizer.Add(delete_btn, 0, wx.BOTTOM | wx.EXPAND, 2)
                else:
                    # Add a spacer for consistency
                    self.buttons_sizer.AddSpacer(
                        wx.Button(self.buttons_panel).GetSize().height + 2
                    )

        # Crucial: Layout the panel containing the buttons AFTER adding them
        self.buttons_panel.Layout()

        # Also layout the parent sizer containing the list and button panel
        if self.events_list.GetContainingSizer():
            self.events_list.GetContainingSizer().Layout()
        else:
            print("NO get containing? ")
            self.log_event("ERRROR continaing size")
        self.log_event("Event list updated.")

    def on_prev_month(self, event):
        """Go to previous month."""
        self.log_event("Previous month requested.")
        if self.current_month > 1:
            self.current_month -= 1
        else:
            self.current_month = 12
            self.current_year -= 1
        self.update_month_display()

    def on_next_month(self, event):
        """Go to next month."""
        self.log_event("Next month requested.")
        if self.current_month < 12:
            self.current_month += 1
        else:
            self.current_month = 1
            self.current_year += 1
        self.update_month_display()

    def update_month_display(self):
        """Update the month/year label and refresh calendar grid with improved responsiveness."""
        self.log_event(
            f"Updating display for month: {self.current_month}/{self.current_year}"
        )

        # Cache old selection
        old_selected_date = self.selected_date

        month_names = [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ]
        self.month_year_label.SetLabel(
            f"{month_names[self.current_month-1]} {self.current_year}"
        )

        # Find the parent panel for the calendar grid
        parent_panel = self.calendar_section

        if parent_panel:
            # Update the grid with the new month
            self.update_calendar_grid(parent_panel)

            # Check if selected date is still valid in the new month/year view
            try:
                # Try to create the same day in the new month
                new_date = datetime.date(
                    self.current_year, self.current_month, old_selected_date.day
                )
                self.selected_date = new_date
            except ValueError:
                # If day is invalid for new month (e.g. Feb 31), select the last day of month
                if self.current_month == 12:
                    last_day = datetime.date(
                        self.current_year + 1, 1, 1
                    ) - datetime.timedelta(days=1)
                else:
                    last_day = datetime.date(
                        self.current_year, self.current_month + 1, 1
                    ) - datetime.timedelta(days=1)

                self.log_event(
                    f"Selected day {old_selected_date.day} invalid for new month, selecting {last_day.day}."
                )
                self.selected_date = last_day

            # Highlight the selected date in the grid without full redraw
            for i, day_btn in enumerate(self.day_buttons):
                if day_btn is not None:
                    first_day = datetime.date(self.current_year, self.current_month, 1)
                    first_weekday = first_day.weekday()

                    if i >= first_weekday:
                        day_num = i - first_weekday + 1
                        if day_num <= 31:  # Safe upper bound
                            try:
                                btn_date = datetime.date(
                                    self.current_year, self.current_month, day_num
                                )
                                if btn_date == self.selected_date:
                                    day_btn.SetBackgroundColour(
                                        wx.Colour(255, 215, 100)
                                    )  # Gold
                                    day_btn.Refresh()
                            except ValueError:
                                pass  # Invalid date, skip

            # Update event list for the (potentially new) selected date
            self.update_events_for_selected_date()

            # Update the events section label
            if hasattr(self, "events_static_box") and self.events_static_box:
                self.events_static_box.SetLabel(
                    f"Events for {self.selected_date.strftime('%Y-%m-%d')}"
                )
                self.events_static_box.Refresh()

            # Only do Layout if we think dimensions changed
            self.Layout()
        else:
            self.log_event("Error: Could not find parent panel for month update.")

    # --- Event Add Functionality ---
    def on_add_event(self, event):
        """Opens a dialog to add a new event."""
        self.log_event("Add event button clicked.")

        dialog = wx.Dialog(self, title="Add New Event", size=(400, 300))
        panel = wx.Panel(dialog)
        vbox = wx.BoxSizer(wx.VERTICAL)

        # Title
        title_label = wx.StaticText(panel, label="Event Title:")
        title_input = wx.TextCtrl(panel)
        vbox.Add(title_label, flag=wx.LEFT | wx.RIGHT | wx.TOP, border=10)
        vbox.Add(
            title_input, flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.BOTTOM, border=10
        )

        # Date (pre-fill with currently selected date)
        date_label = wx.StaticText(panel, label="Event Date:")
        # Convert selected Python date to wx.DateTime
        wx_selected_date = wx.DateTime(
            self.selected_date.day,
            self.selected_date.month - 1,
            self.selected_date.year,
        )
        date_picker = wx.adv.DatePickerCtrl(
            panel, dt=wx_selected_date, style=wx.adv.DP_DEFAULT | wx.adv.DP_SHOWCENTURY
        )
        vbox.Add(date_label, flag=wx.LEFT | wx.RIGHT | wx.TOP, border=10)
        vbox.Add(
            date_picker, flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.BOTTOM, border=10
        )

        # Time
        time_label = wx.StaticText(panel, label="Event Time:")
        time_picker = wx.adv.TimePickerCtrl(panel, style=wx.adv.TP_DEFAULT)
        # Set a default time, e.g., next hour? Or 00:00?
        # time_picker.SetValue(wx.DateTime.Now()) # Set to current time
        vbox.Add(time_label, flag=wx.LEFT | wx.RIGHT | wx.TOP, border=10)
        vbox.Add(
            time_picker, flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.BOTTOM, border=10
        )

        # Buttons
        button_sizer = wx.StdDialogButtonSizer()
        ok_button = wx.Button(panel, wx.ID_OK)
        ok_button.SetDefault()
        cancel_button = wx.Button(panel, wx.ID_CANCEL)
        button_sizer.AddButton(ok_button)
        button_sizer.AddButton(cancel_button)
        button_sizer.Realize()
        vbox.Add(button_sizer, flag=wx.ALIGN_CENTER | wx.ALL, border=10)

        panel.SetSizer(vbox)
        panel.Fit()
        dialog.Fit()
        dialog.Centre()

        # --- Handler for successful add response ---
        # Defined here to capture 'self' and potentially dialog inputs if needed later
        def on_add_success(parent_dialog_self, _, *params, net):
            self_outer = parent_dialog_self  # Reference to EventsDialog instance
            self_outer.log_event(f"Received ADD_SUCCESS from server. Params: {params}")
            if not params:
                self_outer.log_event("Error: ADD_SUCCESS received no parameters.")
                wx.CallAfter(
                    wx.MessageBox,
                    "Server confirmed adding event, but sent no data back.",
                    "Warning",
                    wx.OK | wx.ICON_WARNING,
                    self_outer,
                )
                return

            try:
                # Assuming server sends back the *single* added event, pickled and base64 encoded
                pickled_event_b64 = params[0]
                pickled_event = base64.b64decode(pickled_event_b64)
                new_event = pickle.loads(pickled_event)  # Should be a single dict

                self_outer.log_event(
                    f"Successfully decoded new event: {new_event.get('event_title')} ID: {new_event.get('id')}"
                )

                # Add the new event to the main list
                self_outer.events.append(new_event)

                # Reorganize and refresh UI
                self_outer.organize_events_by_date()

                # Need to find the parent panel to update grid
                # This is awkward here. It's better if setup_ui is called, or update methods handle finding panel
                # Let's call setup_ui for simplicity, although it's less efficient
                wx.CallAfter(self_outer.setup_ui)  # Refresh the whole dialog UI

                # Optionally show a success message
                # wx.CallAfter(wx.MessageBox, f"Event '{new_event['event_title']}' added successfully.", "Event Added", wx.OK | wx.ICON_INFORMATION, self_outer)

            except Exception as e:
                self_outer.log_event(f"Error processing ADD_SUCCESS: {e}")
                wx.CallAfter(
                    wx.MessageBox,
                    f"Error processing server confirmation: {e}",
                    "Error",
                    wx.OK | wx.ICON_ERROR,
                    self_outer,
                )

        # --- Show Dialog and Handle Result ---
        if dialog.ShowModal() == wx.ID_OK:
            event_title = title_input.GetValue()
            event_wxdate = date_picker.GetValue()
            event_wxtime = (
                time_picker.GetValue()
            )  # wx.DateTime object containing H, M, S

            # Validate inputs
            if not event_title:
                self.log_event("Add event failed: No title entered.")
                wx.MessageBox(
                    "Please enter an event title.", "Error", wx.OK | wx.ICON_ERROR, self
                )
                dialog.Destroy()  # Destroy the dialog
                return

            # Convert wx date and time to Python datetime
            py_date = datetime.date(
                event_wxdate.GetYear(),
                event_wxdate.GetMonth() + 1,
                event_wxdate.GetDay(),
            )
            py_time = datetime.time(
                event_wxtime.GetHour(),
                event_wxtime.GetMinute(),
                event_wxtime.GetSecond(),
            )
            event_datetime = datetime.datetime.combine(py_date, py_time)

            self.log_event(
                f"Attempting to add event: '{event_title}' at {event_datetime}"
            )

            # Format for sending (server expects string?)
            datetime_str = event_datetime.strftime(
                "%Y-%m-%d %H:%M:%S"
            )  # ISO-like format

            # Add the handler *before* sending the message
            # Pass 'self' (the EventsDialog instance) to the handler
            self.net.add_handler(
                "EVENT_SUCCESS", lambda *p, net: on_add_success(self, *p, net=net)
            )
            print("added handler")
            # Send to server
            self.net.send_message(
                self.net.build_message("ADDEVENT", [event_title, datetime_str])
            )
            self.log_event("ADDEVENT message sent to server.")

            # We don't add to self.events here; we wait for ADD_SUCCESS confirmation
            # dialog.Destroy() should happen AFTER ShowModal returns
        else:
            self.log_event("Add event dialog cancelled by user.")

        dialog.Destroy()  # Ensure dialog is destroyed

    # --- Event Deletion ---
    def on_delete_btn(self, event, delete_id, *, net=None):
        """Handles delete event button click."""
        button_pressed = event.GetEventObject()
        # Retrieve the event ID stored in the button's help text instead of client data
        print("Deleteing helptext=", button_pressed.GetHelpText())
        event_id_to_delete = delete_id
        print("DELETING event_id_to_delete=", delete_id)
        if not event_id_to_delete:
            self.log_event("Error: Delete button pressed but no event ID found.")
            return

        self.log_event(f"Delete button clicked for event ID: {event_id_to_delete}")

        # Confirmation Dialog
        confirm_dialog = wx.MessageDialog(
            self,
            "Are you sure you want to delete this event?",  # Add event title later if needed
            "Confirm Deletion",
            wx.YES_NO | wx.NO_DEFAULT | wx.ICON_WARNING,
        )

        if confirm_dialog.ShowModal() == wx.ID_YES:
            self.log_event(f"Deletion confirmed for event ID: {event_id_to_delete}")

            # --- Nested Handler for successful delete response ---
            # Defined here to capture 'self' and 'event_id_to_delete'
            def on_delete_success(parent_dialog_self, *params, net):
                # Use the captured self (parent_dialog_self) and event_id_to_delete
                self_outer = parent_dialog_self
                deleted_id_str = str(event_id_to_delete)  # Use the captured ID

                # Check if the success message matches the ID we tried to delete
                if params and str(params[1]) == deleted_id_str:
                    self_outer.log_event(
                        f"Received DELETE_SUCCESS confirmation for ID: {deleted_id_str}"
                    )

                    # Remove event from the local list
                    initial_count = len(self_outer.events)
                    self_outer.events = [
                        ev
                        for ev in self_outer.events
                        if str(ev.get("id")) != deleted_id_str
                    ]
                    final_count = len(self_outer.events)

                    if final_count < initial_count:
                        self_outer.log_event(
                            f"Event ID {deleted_id_str} removed locally."
                        )
                        # Reorganize and refresh UI
                        self_outer.organize_events_by_date()
                        # Refresh the whole UI to ensure consistency
                        wx.CallAfter(self_outer.setup_ui)
                    else:
                        self_outer.log_event(
                            f"Warning: DELETE_SUCCESS received for {deleted_id_str}, but event not found in local list."
                        )

                else:
                    self_outer.log_event(
                        f"Warning: Received DELETE_SUCCESS, but params {params[1]} didn't match expected ID {deleted_id_str}."
                    )
                    wx.CallAfter(
                        wx.MessageBox,
                        f"Server confirmed deletion, but for an unexpected ID ({params[1] if params else 'None'}). Please refresh.",
                        "Warning",
                        wx.OK | wx.ICON_WARNING,
                        self_outer,
                    )

            # Add the specific handler for this deletion request
            # It needs to check if the success message corresponds to *this* deletion
            self.net.add_handler(
                "DELETE_SUCCESS", lambda *p, net: on_delete_success(self, *p, net=net)
            )

            # Send delete request to server
            self.net.send_message(
                self.net.build_message("DELETEEVENT", [str(event_id_to_delete)])
            )
            self.log_event(f"DELETEEVENT message sent for ID: {event_id_to_delete}")
        else:
            self.log_event(f"Deletion cancelled for event ID: {event_id_to_delete}")

        confirm_dialog.Destroy()

    # --- Other Actions ---
    def on_close(self, event):
        self.log_event("Close button clicked.")
        self.Close()

    def authenticate_google(self):
        """Authenticate with Google Calendar API"""
        self.log_event("Attempting Google authentication.")
        SCOPES = ["https://www.googleapis.com/auth/calendar.readonly"]
        creds = None
        token_file = "token.pickle"
        creds_file = "credentials.json"  # Make sure this file exists

        if not os.path.exists(creds_file):
            self.log_event(f"Error: {creds_file} not found.")
            self.show_error(
                f"{creds_file} not found. Please download it from Google Cloud Console and place it in the application directory."
            )
            return False

        if os.path.exists(token_file):
            try:
                with open(token_file, "rb") as token:
                    creds = pickle.load(token)
                self.log_event("Loaded credentials from token.pickle.")
            except Exception as e:
                self.log_event(
                    f"Error loading token.pickle: {e}. Will re-authenticate."
                )
                creds = None  # Force re-authentication

        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                try:
                    self.log_event("Refreshing expired Google credentials.")
                    creds.refresh(Request())
                except Exception as e:
                    self.log_event(
                        f"Error refreshing token: {e}. Re-authentication required."
                    )
                    creds = None  # Force re-authentication
                    # Optionally delete the bad token file
                    if os.path.exists(token_file):
                        os.remove(token_file)

            else:
                try:
                    self.log_event("No valid credentials found. Starting OAuth flow.")
                    flow = InstalledAppFlow.from_client_secrets_file(creds_file, SCOPES)
                    # Make run_local_server use a specific port if needed, 0 picks random available
                    creds = flow.run_local_server(port=0)
                    self.log_event("OAuth flow completed successfully.")
                except Exception as e:
                    self.log_event(f"Error during OAuth flow: {e}")
                    self.show_error(f"Failed to authenticate with Google: {e}")
                    return False

            # Save the credentials for the next run
            try:
                with open(token_file, "wb") as token:
                    pickle.dump(creds, token)
                self.log_event("Saved new credentials to token.pickle.")
            except Exception as e:
                self.log_event(f"Error saving token.pickle: {e}")

        try:
            self.service = build("calendar", "v3", credentials=creds)
            self.log_event("Google Calendar service built successfully.")
            return True
        except Exception as e:
            self.log_event(f"Error building Google Calendar service: {e}")
            self.show_error(f"Failed to build Google Calendar service: {e}")
            return False

    def fetch_google_events(self, days_to_fetch=365):
        """Fetch events from Google Calendar"""
        self.log_event(
            f"Fetching Google Calendar events for the next {days_to_fetch} days."
        )
        if not self.service:
            self.log_event("Google service not available. Attempting authentication.")
            if not self.authenticate_google():
                self.log_event("Authentication failed. Cannot fetch events.")
                return []

        now = datetime.datetime.utcnow()
        end_date = now + datetime.timedelta(days=days_to_fetch)
        now_str = now.isoformat() + "Z"
        end_str = end_date.isoformat() + "Z"

        try:
            events_result = (
                self.service.events()
                .list(
                    calendarId="primary",
                    timeMin=now_str,
                    timeMax=end_str,
                    singleEvents=True,
                    orderBy="startTime",
                )
                .execute()
            )
            gcal_events = events_result.get("items", [])
            self.log_event(f"Fetched {len(gcal_events)} events from Google Calendar.")
        except Exception as e:
            self.log_event(f"Error fetching Google Calendar events: {e}")
            self.show_error(f"Error fetching events from Google Calendar: {e}")
            return []

        formatted_events = []
        for event in gcal_events:
            summary = event.get("summary", "Untitled Event")
            start_info = event.get("start", {})
            start = start_info.get(
                "dateTime", start_info.get("date")
            )  # dateTime is preferred

            if not start:
                self.log_event(
                    f"Skipping event '{summary}' - no start date/time found."
                )
                continue

            try:
                # Handle date vs datetime
                if len(start) == 10:  # 'YYYY-MM-DD' format (all-day event)
                    event_dt = datetime.datetime.strptime(start, "%Y-%m-%d")
                    # Assign a default time (e.g., midnight) or handle as needed
                    event_dt = event_dt.replace(hour=0, minute=0, second=0)
                else:  # Assume ISO format 'YYYY-MM-DDTHH:MM:SS...'
                    # Make timezone aware if possible, otherwise naive UTC assumed by 'Z'
                    if "T" in start:
                        # Handle potential timezone offsets or 'Z'
                        if start.endswith("Z"):
                            start = start[:-1] + "+00:00"  # Replace Z with UTC offset
                        try:
                            event_dt = datetime.datetime.fromisoformat(start)
                            # Convert to local time if timezone aware
                            if event_dt.tzinfo:
                                event_dt = event_dt.astimezone(
                                    datetime.datetime.now().astimezone().tzinfo
                                )
                            event_dt = event_dt.replace(
                                tzinfo=None
                            )  # Make naive for internal use
                        except ValueError:
                            self.log_event(
                                f"Warning: Could not parse complex date '{start}' for event '{summary}'. Using now()."
                            )
                            event_dt = datetime.datetime.now()  # Fallback
                    else:
                        # Fallback if format is unexpected
                        self.log_event(
                            f"Warning: Unexpected date format '{start}' for event '{summary}'. Using now()."
                        )
                        event_dt = datetime.datetime.now()

                formatted_event = {
                    "id": -1,  # Indicate it's newly imported, needs saving
                    "event_title": summary,
                    "event_date": event_dt,  # Store as Python datetime
                    "createTime": datetime.datetime.now(),  # Set creation time to now
                }
                formatted_events.append(formatted_event)

            except ValueError as ve:
                self.log_event(
                    f"Error parsing date '{start}' for event '{summary}': {ve}"
                )
            except Exception as e:
                self.log_event(f"Unexpected error processing event '{summary}': {e}")

        self.log_event(f"Formatted {len(formatted_events)} Google events for import.")
        return formatted_events

    def on_import_gcal(self, event):
        """Handle Google Calendar import button click"""
        self.log_event("Import from Google Calendar button clicked.")
        
        # Create a progress dialog that doesn't block the UI
        progress_dialog = wx.ProgressDialog(
            "Google Calendar Import",
            "Connecting to Google Calendar and fetching events...",
            maximum=100,
            parent=self,
            style=wx.PD_APP_MODAL | wx.PD_AUTO_HIDE
        )
        
        # Update to show it's working (indeterminate progress)
        progress_dialog.Pulse()
        
        # Define the thread function
        def import_thread():
            try:
                new_events = self.fetch_google_events()
                # Use CallAfter to interact with UI from the worker thread
                wx.CallAfter(progress_dialog.Destroy)  # Properly close the dialog
                wx.CallAfter(self.show_imported_events, new_events)
            except Exception as e:
                wx.CallAfter(progress_dialog.Destroy)  # Ensure dialog is closed on error
                self.log_event(f"Error in import thread: {e}")
                # Show error message in the main thread
                wx.CallAfter(
                    self.show_error, f"Error importing Google events: {str(e)}"
                )
        
        # Start the thread
        thread = threading.Thread(target=import_thread)
        thread.daemon = True  # Allow program to exit even if thread is running
        thread.start()
        self.log_event("Google import thread started.")
        
        # Allow UI updates while waiting
        wx.Yield()
    
    def show_imported_events(self, imported_events):
        """Display imported events and ask for confirmation"""
        try:
            self.log_event(
                f"Showing {len(imported_events)} imported events for confirmation."
            )
            if not imported_events:
                wx.MessageBox(
                    "No new events found in your Google Calendar for the specified period.",
                    "No Events Found",
                    wx.OK | wx.ICON_INFORMATION,
                    self,
                )
                return

            dialog = wx.Dialog(
                self, title="Confirm Google Calendar Import", size=(500, 400)
            )
            panel = wx.Panel(dialog)
            vbox = wx.BoxSizer(wx.VERTICAL)

            vbox.Add(
                wx.StaticText(
                    panel, label="Add the following events from Google Calendar?"
                ),
                flag=wx.ALL,
                border=10,
            )

            event_list = wx.ListCtrl(panel, style=wx.LC_REPORT)
            event_list.InsertColumn(0, "Title", width=250)
            event_list.InsertColumn(1, "Date & Time", width=180)

            for i, event in enumerate(imported_events):
                index = event_list.InsertItem(i, event["event_title"])
                event_list.SetItem(index, 1, event["event_date"].strftime("%Y-%m-%d %H:%M"))

            vbox.Add(event_list, proportion=1, flag=wx.EXPAND | wx.ALL, border=10)

            btn_sizer = wx.StdDialogButtonSizer()
            import_btn = wx.Button(panel, wx.ID_OK, label="Add These Events")
            cancel_btn = wx.Button(panel, wx.ID_CANCEL, label="Cancel")
            btn_sizer.AddButton(import_btn)
            btn_sizer.AddButton(cancel_btn)
            btn_sizer.Realize()

            vbox.Add(btn_sizer, flag=wx.ALIGN_CENTER | wx.ALL, border=10)
            panel.SetSizer(vbox)
            panel.Fit()
            dialog.Fit()
            dialog.Centre()

            if dialog.ShowModal() == wx.ID_OK:
                self.log_event(f"User confirmed import of {len(imported_events)} events.")
                # Add events to our list - they already have id = -1
                self.events.extend(imported_events)
                self.organize_events_by_date()
                self.setup_ui()  # Refresh UI fully
                wx.MessageBox(
                    f"Added {len(imported_events)} events. Remember to 'Save Events to Server'.",
                    "Import Successful",
                    wx.OK | wx.ICON_INFORMATION,
                    self,
                )
            else:
                self.log_event("User cancelled Google event import.")

            dialog.Destroy()
        except Exception as e:
            import traceback
            traceback.print_exc()
    def show_error(self, message):
        """Show error message dialog."""
        self.log_event(f"Displaying error: {message}")
        wx.MessageBox(message, "Error", wx.OK | wx.ICON_ERROR, self)

    def on_save_to_server(self, event):
        """Handle saving newly added/imported events to server."""
        self.log_event("Save to Server button clicked.")

        # Filter events that haven't been saved yet (assume id == -1)
        events_to_save = [ev for ev in self.events if ev.get("id") == -1]

        if not events_to_save:
            self.log_event("No new events to save.")
            wx.MessageBox(
                "No new events to save to the server.",
                "Nothing to Save",
                wx.OK | wx.ICON_INFORMATION,
                self,
            )
            return

        self.log_event(f"Found {len(events_to_save)} new events to save.")
        # Print for debugging, remove later
        # print("Events to save to server:")
        # for ev in events_to_save: print(f"  Title: {ev['event_title']}, Date: {ev['event_date']}")

        try:
            # Serialize the list of events to save
            pickled_data = pickle.dumps(events_to_save)
            encoded_data = base64.b64encode(pickled_data).decode("utf-8")  # Use utf-8

            # Add handler for save success? Assume server sends back updated events?
            # For now, just send. Need server response spec.
            # self.net.add_handler("SAVE_SUCCESS", self.handle_save_success)

            # Send the encoded data
            self.net.send_message(self.net.build_message("SAVE_EVENTS", [encoded_data]))
            self.log_event("SAVE_EVENTS message sent to server.")

            # Optionally clear the id=-1 flag locally *after* successful confirmation
            # For now, we assume the server will send back updated event list on connect/refresh

            wx.MessageBox(
                f"Sent {len(events_to_save)} new event(s) to the server for saving.",
                "Save Request Sent",
                wx.OK | wx.ICON_INFORMATION,
                self,
            )

        except Exception as e:
            self.log_event(f"Error pickling or sending events to save: {e}")
            self.show_error(f"Error preparing events for saving: {e}")


# Example usage (requires a dummy parent and net object for standalone running)
if __name__ == "__main__":

    # --- Dummy Network Class ---
    class DummyNetwork:
        def __init__(self):
            self.handlers = {}
            print("DummyNetwork Initialized")

        def add_handler(self, command, handler_func):
            print(f"DummyNetwork: Adding handler for {command}")
            self.handlers[command] = handler_func

        def build_message(self, command, params):
            print(f"DummyNetwork: Building message {command} with params {params}")
            return f"{command}~" + "~".join(map(str, params))  # Simple pipe delimiter

        def send_message(self, message):
            print(f"DummyNetwork: Sending message: {message}")
            # --- Simulate Server Responses ---
            parts = message.split("~", 1)
            command = parts[0]
            params = parts[1].split("~") if len(parts) > 1 else []

            if command == "DELETEEVENT":
                event_id = params[0]
                print(f"Simulating DELETE_SUCCESS for ID {event_id}")
                if "DELETE_SUCCESS" in self.handlers:
                    # Need to run handler slightly later to avoid UI recursion issues
                    wx.CallLater(
                        100, self.handlers["DELETE_SUCCESS"], event_id,net=self
                    )  # Pass back the ID

            elif command == "ADDEVENT":
                title, dt_str = params
                print(f"Simulating ADD_SUCCESS for title '{title}'")
                # Create a fake new event dict
                new_id = datetime.datetime.now().microsecond  # Fake unique ID
                new_event = {
                    "id": new_id,
                    "event_title": title + " (Added)",
                    "event_date": datetime.datetime.strptime(
                        dt_str, "%Y-%m-%d %H:%M:%S"
                    ),
                    "createTime": datetime.datetime.now(),
                }
                # Pickle and encode it
                pickled_event = pickle.dumps(new_event)
                encoded_event = base64.b64encode(pickled_event).decode()
                if "ADD_SUCCESS" in self.handlers:
                    wx.CallLater(100, self.handlers["ADD_SUCCESS"], encoded_event,net=self)

            elif command == "SAVE_EVENTS":
                print(
                    "Simulating server received SAVE_EVENTS. No specific reply defined yet."
                )
                # Potentially simulate a refresh or updated event list later

    # --- Dummy Parent Frame ---
    class DummyFrame(wx.Frame):
        def __init__(self):
            super().__init__(None, title="Main App")
            self.net = DummyNetwork()  # Frame owns the network connection
            # Add button to open dialog
            panel = wx.Panel(self)
            button = wx.Button(panel, label="Open Events Calendar")
            button.Bind(wx.EVT_BUTTON, self.show_events)
            sizer = wx.BoxSizer(wx.VERTICAL)
            sizer.Add(button, 0, wx.ALL | wx.CENTER, 20)
            panel.SetSizer(sizer)
            self.Show()

        def show_events(self, event):
            # --- Sample Events Data ---
            now = datetime.datetime.now()
            sample_events = [
                {
                    "id": 1,
                    "event_title": "Team Meeting",
                    "event_date": now.replace(hour=10, minute=0, second=0),
                    "createTime": now - datetime.timedelta(days=1),
                },
                {
                    "id": 2,
                    "event_title": "Project Deadline",
                    "event_date": now + datetime.timedelta(days=2, hours=3),
                    "createTime": now - datetime.timedelta(days=5),
                },
                {
                    "id": 3,
                    "event_title": "Lunch with Client",
                    "event_date": now.replace(hour=12, minute=30, second=0),
                    "createTime": now - datetime.timedelta(hours=4),
                },
                {
                    "id": 4,
                    "event_title": "Past Event",
                    "event_date": now - datetime.timedelta(days=1, hours=2),
                    "createTime": now - datetime.timedelta(days=10),
                },
                # Event on a different day
                {
                    "id": 5,
                    "event_title": "Future Planning",
                    "event_date": now + datetime.timedelta(days=5, hours=14),
                    "createTime": now - datetime.timedelta(days=1),
                },
            ]
            # Ensure dates are datetime objects
            for ev in sample_events:
                if isinstance(ev["event_date"], str):
                    ev["event_date"] = datetime.datetime.fromisoformat(ev["event_date"])
                if isinstance(ev["createTime"], str):
                    ev["createTime"] = datetime.datetime.fromisoformat(ev["createTime"])

            # Pass events, self (as parent), and network object
            dlg = EventsDialog(sample_events, self, self.net, debug=True)
            dlg.ShowModal()
            dlg.Destroy()

    app = wx.App(False)
    frame = DummyFrame()
    app.MainLoop()


// ----- FontDiag.py -----
import wx
import os
import tempfile
import urllib.request


class FontSelectorDialog(wx.Dialog):
    def __init__(self, parent, net):
        super().__init__(parent, title="Font Selector", size=(600, 550))
        self.parent = parent
        self.net = net
        self.custom_font_path = None
        self.selected_font = None
        self.from_url = False

        panel = wx.Panel(self)
        main_sizer = wx.BoxSizer(wx.VERTICAL)

        notebook = wx.Notebook(panel)
        self.system_panel = wx.Panel(notebook)
        self.url_panel = wx.Panel(notebook)

        # System Fonts Tab
        system_sizer = wx.BoxSizer(wx.VERTICAL)
        system_fonts_label = wx.StaticText(
            self.system_panel, label="Available System Fonts:"
        )
        system_sizer.Add(system_fonts_label, flag=wx.LEFT | wx.TOP, border=10)

        font_enumerator = wx.FontEnumerator()
        font_enumerator.EnumerateFacenames()
        system_fonts = sorted(font_enumerator.GetFacenames())
        self.system_fonts_list = wx.ListBox(self.system_panel, choices=system_fonts)
        system_sizer.Add(
            self.system_fonts_list, proportion=1, flag=wx.EXPAND | wx.ALL, border=10
        )
        self.system_panel.SetSizer(system_sizer)

        # URL Fonts Tab
        url_sizer = wx.BoxSizer(wx.VERTICAL)
        url_label = wx.StaticText(
            self.url_panel, label="Download font from URL (.ttf or .otf):"
        )
        url_sizer.Add(url_label, flag=wx.LEFT | wx.TOP, border=10)

        self.url_input = wx.TextCtrl(self.url_panel)
        url_sizer.Add(
            self.url_input, flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, border=10
        )

        download_button = wx.Button(self.url_panel, label="Download & Add to List")
        url_sizer.Add(download_button, flag=wx.ALL, border=10)

        self.url_fonts_list = wx.ListBox(self.url_panel)
        url_sizer.Add(
            self.url_fonts_list, proportion=1, flag=wx.EXPAND | wx.ALL, border=10
        )
        self.url_panel.SetSizer(url_sizer)

        notebook.AddPage(self.system_panel, "System Fonts")
        notebook.AddPage(self.url_panel, "From URL")
        main_sizer.Add(notebook, proportion=2, flag=wx.EXPAND | wx.ALL, border=10)

        # Preview
        preview_label = wx.StaticText(panel, label="Preview:")
        main_sizer.Add(preview_label, flag=wx.LEFT | wx.TOP, border=10)

        self.preview_text = wx.TextCtrl(
            panel,
            value="The quick brown fox jumps over the lazy dog",
            style=wx.TE_MULTILINE | wx.TE_READONLY,
        )
        self.preview_text.SetMinSize((580, 60))
        main_sizer.Add(self.preview_text, flag=wx.EXPAND | wx.ALL, border=10)

        # Buttons
        button_sizer = wx.StdDialogButtonSizer()
        self.ok_button = wx.Button(panel, wx.ID_OK)
        self.ok_button.Enable(False)
        self.ok_button.SetDefault()
        cancel_button = wx.Button(panel, wx.ID_CANCEL)

        button_sizer.AddButton(self.ok_button)
        button_sizer.AddButton(cancel_button)
        button_sizer.Realize()
        main_sizer.Add(button_sizer, flag=wx.ALIGN_CENTER | wx.ALL, border=10)

        panel.SetSizer(main_sizer)

        # Bind Events
        self.system_fonts_list.Bind(wx.EVT_LISTBOX, self.on_system_font_selected)
        self.url_fonts_list.Bind(wx.EVT_LISTBOX, self.on_url_font_selected)
        download_button.Bind(wx.EVT_BUTTON, self.on_download_font)

    def on_system_font_selected(self, event):
        font_name = self.system_fonts_list.GetStringSelection()
        if font_name:
            self.selected_font = font_name
            self.from_url = False
            self.ok_button.Enable(True)
            self.set_preview_font(font_name)

    def on_url_font_selected(self, event):
        font_name = self.url_fonts_list.GetStringSelection()
        if font_name:
            self.selected_font = font_name
            self.from_url = True
            self.ok_button.Enable(True)
            self.set_preview_font(font_name)

    def set_preview_font(self, font_name):
        font = wx.Font(
            12,
            wx.FONTFAMILY_DEFAULT,
            wx.FONTSTYLE_NORMAL,
            wx.FONTWEIGHT_NORMAL,
            False,
            font_name,
        )
        self.preview_text.SetFont(font)

    def on_download_font(self, event):
        url = self.url_input.GetValue().strip()
        if not url:
            wx.MessageBox("Please enter a URL", "Error", wx.OK | wx.ICON_ERROR)
            return
        if not (url.lower().endswith(".ttf") or url.lower().endswith(".otf")):
            wx.MessageBox(
                "URL must point to a .ttf or .otf file", "Error", wx.OK | wx.ICON_ERROR
            )
            return

        try:
            progress_dialog = wx.ProgressDialog(
                "Downloading Font",
                "Downloading...",
                maximum=100,
                parent=self,
                style=wx.PD_APP_MODAL | wx.PD_AUTO_HIDE,
            )

            temp_dir = tempfile.gettempdir()
            font_filename = os.path.basename(url)
            self.custom_font_path = os.path.join(temp_dir, font_filename)

            def reporthook(blocknum, blocksize, totalsize):
                if totalsize > 0:
                    percent = min(int(blocknum * blocksize * 100 / totalsize), 100)
                    progress_dialog.Update(percent)

            urllib.request.urlretrieve(url, self.custom_font_path, reporthook)
            progress_dialog.Destroy()

            if wx.Font.AddPrivateFont(self.custom_font_path):
                font_name = os.path.splitext(font_filename)[0]
                self.selected_font = font_name
                self.from_url = True

                # Add to list if not already there
                if font_name not in self.url_fonts_list.GetItems():
                    self.url_fonts_list.Append(font_name)

                self.url_fonts_list.SetStringSelection(font_name)
                self.set_preview_font(font_name)
                self.ok_button.Enable(True)

                wx.MessageBox(
                    f"Font '{font_name}' downloaded successfully",
                    "Success",
                    wx.OK | wx.ICON_INFORMATION,
                )
            else:
                wx.MessageBox(
                    "Failed to load the downloaded font", "Error", wx.OK | wx.ICON_ERROR
                )
                self.custom_font_path = None

        except Exception as e:
            wx.MessageBox(
                f"Error downloading font: {str(e)}", "Error", wx.OK | wx.ICON_ERROR
            )
            self.custom_font_path = None


# Basic test under __main__
if __name__ == "__main__":

    class DummyNet:
        pass

    app = wx.App(False)
    dlg = FontSelectorDialog(None, DummyNet())
    dlg.ShowModal()
    dlg.Destroy()
    app.MainLoop()


// ----- GraphDial.py -----
import wx
import math
import collections


class GraphDialog(wx.Dialog):
    def __init__(self, parent, root_nodes, network_manager):
        super().__init__(parent, title="Summary Graph View", size=(800, 600))
        self.net = network_manager

        # Store root nodes directly - no flattening
        self.root_nodes = root_nodes

        # Build a mapping of all node IDs to nodes
        self.node_map = {}
        self._build_node_map(root_nodes)

        # --- UI Setup ---
        panel = wx.Panel(self)
        sizer = wx.BoxSizer(wx.VERTICAL)

        instructions = wx.StaticText(
            panel,
            label="Click a node to select it; double-click or use the 'View' button to open its summary.",
        )
        sizer.Add(instructions, 0, wx.ALL, 10)

        self.canvas = wx.Panel(panel, style=wx.BORDER_SUNKEN)
        self.canvas.SetBackgroundColour(wx.WHITE)
        self.canvas.Bind(wx.EVT_PAINT, self._on_paint)
        self.canvas.Bind(wx.EVT_LEFT_DOWN, self._on_click)
        self.canvas.Bind(wx.EVT_LEFT_DCLICK, self._on_double_click)
        sizer.Add(self.canvas, 1, wx.EXPAND | wx.ALL, 10)

        self.info_label = wx.StaticText(panel, label="No node selected")
        sizer.Add(self.info_label, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 10)

        btn_sizer = wx.BoxSizer(wx.HORIZONTAL)
        self.view_btn = wx.Button(panel, label="View Selected Summary")
        self.view_btn.Bind(wx.EVT_BUTTON, self._on_view)
        self.view_btn.Disable()
        close_btn = wx.Button(panel, label="Close")
        close_btn.Bind(wx.EVT_BUTTON, lambda e: self.EndModal(wx.ID_CANCEL))
        btn_sizer.Add(self.view_btn, 0, wx.RIGHT, 10)
        btn_sizer.Add(close_btn)
        sizer.Add(btn_sizer, 0, wx.ALIGN_RIGHT | wx.ALL, 10)

        panel.SetSizer(sizer)
        self.SetMinSize((600, 500))

        self.selected_id = None
        self.node_positions = {}
        self.node_sizes = {}

        # Delay layout until shown
        self.Bind(wx.EVT_SHOW, self._on_show)

    def _build_node_map(self, nodes):
        """Build a map of node IDs to nodes, handling duplicates"""
        for node in nodes:
            self.node_map[node.id] = node

            # We don't recursively add children here, as they might be
            # node IDs rather than actual nodes

    def _on_show(self, event):
        if event.IsShown():
            wx.CallAfter(self._layout)

    def _layout(self):
        self._compute_positions()
        self.canvas.Refresh()

    def _compute_positions(self):
        w, h = self.canvas.GetClientSize()
        w, h = max(w, 600), max(h, 400)

        # First, compute the position of all root nodes
        self.node_positions = {}
        self.node_sizes = {}

        # Position root nodes in a row at the top
        y = 50
        padding = 100
        available_width = w - (2 * padding)

        if len(self.root_nodes) == 1:
            x_positions = [w / 2]
        else:
            step = available_width / max(1, len(self.root_nodes) - 1)
            x_positions = [padding + i * step for i in range(len(self.root_nodes))]

        # Assign positions to root nodes
        for i, node in enumerate(self.root_nodes):
            self.node_positions[node.id] = (x_positions[i], y)
            # Size based on number of connections
            deg = len(node.children)
            self.node_sizes[node.id] = 30 + min(deg * 5, 30)

        # Now compute positions for children recursively
        self._position_children(self.root_nodes, y, w, h)

        # Display stats for debugging
        print(f"Positioned {len(self.node_positions)} nodes")

    def _position_children(self, parent_nodes, parent_y, width, height):
        """Position all children of the given parent nodes"""
        if not parent_nodes:
            return

        # Collect all unique child IDs, accounting for shared children
        all_children = {}  # Map from child ID to node if available

        for parent in parent_nodes:
            for child_id in parent.children:
                # Try to get actual node if available
                child_node = self.node_map.get(child_id)
                if child_node:
                    all_children[child_id] = child_node
                else:
                    # Just store the ID if the node isn't available
                    all_children[child_id] = child_id

        if not all_children:
            return

        # Calculate y position for this level
        y = parent_y + 100  # Fixed vertical spacing

        # Position children horizontally
        padding = 100
        available_width = width - (2 * padding)
        child_ids = list(all_children.keys())

        if len(child_ids) == 1:
            x_positions = [width / 2]
        else:
            step = available_width / max(1, len(child_ids) - 1)
            x_positions = [padding + i * step for i in range(len(child_ids))]

        # Assign positions to children
        actual_child_nodes = []
        for i, child_id in enumerate(child_ids):
            self.node_positions[child_id] = (x_positions[i], y)

            # If we have the actual node, size it and add to list for next level
            child = all_children[child_id]
            if isinstance(child, str):
                # Just an ID, use default size
                self.node_sizes[child_id] = 30
            else:
                # Actual node object
                deg = len(child.children)
                self.node_sizes[child_id] = 30 + min(deg * 5, 30)
                actual_child_nodes.append(child)

        # Recursively position the next level of children
        self._position_children(actual_child_nodes, y, width, height)

    def _on_paint(self, event):
        dc = wx.PaintDC(self.canvas)
        dc.Clear()
        gc = wx.GraphicsContext.Create(dc)
        if not gc:
            return

        # First draw all connections
        pen = wx.Pen(wx.Colour(100, 100, 200), 1)
        gc.SetPen(pen)

        # Process all nodes in our node map
        for node_id, node in self.node_map.items():
            if node_id not in self.node_positions:
                continue

            sx, sy = self.node_positions[node_id]

            # Draw connections to all children
            for child_id in node.children:
                if child_id not in self.node_positions:
                    continue

                tx, ty = self.node_positions[child_id]
                gc.StrokeLine(sx, sy, tx, ty)
                self._draw_arrow(gc, sx, sy, tx, ty)

        # Then draw all nodes we have positions for
        for node_id, (x, y) in self.node_positions.items():
            r = self.node_sizes.get(node_id, 30) / 2

            # Get node if available - properly retrieve the node for THIS node_id
            node = self.node_map.get(node_id)

            # Determine color
            if self.selected_id == node_id:
                gc.SetPen(wx.Pen(wx.BLACK, 2))
                gc.SetBrush(gc.CreateBrush(wx.Brush(wx.Colour(255, 200, 0))))
            elif node and hasattr(node, "type"):
                clr = (
                    wx.Colour(100, 200, 100)
                    if node.type == "summary"
                    else wx.Colour(100, 150, 255)
                )
                gc.SetPen(wx.Pen(wx.BLACK, 1))
                gc.SetBrush(gc.CreateBrush(wx.Brush(clr)))
            else:
                # Default color for nodes without type information
                gc.SetPen(wx.Pen(wx.BLACK, 1))
                gc.SetBrush(gc.CreateBrush(wx.Brush(wx.Colour(180, 180, 180))))

            gc.DrawEllipse(x - r, y - r, 2 * r, 2 * r)

            # Draw label - fixed to properly look up node by its ID
            print("Looking up: ", node_id)
            current_node = node_id
            if type(node_id) is int:
                current_node = self.node_map.get(node_id)

            name = (
                current_node.name
                if current_node and hasattr(current_node, "name")
                else str(node_id)
            )
            if len(name) > 15:
                name = name[:12] + "..."

            font = wx.Font(
                8, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD
            )
            gc.SetFont(gc.CreateFont(font, wx.BLACK))
            tw, th = gc.GetTextExtent(name)
            gc.DrawText(name, x - tw / 2, y + r + 5)

    def _draw_arrow(self, gc, x1, y1, x2, y2):
        dx, dy = x2 - x1, y2 - y1
        dist = math.hypot(dx, dy)
        if dist < 10:
            return

        ux, uy = dx / dist, dy / dist  # Unit vector in direction of arrow
        px, py = -uy, ux  # Perpendicular vector

        # Calculate node radius at destination
        r = 0
        dest_id = self._find_node_at(x2, y2)
        if dest_id and dest_id in self.node_sizes:
            r = self.node_sizes[dest_id] / 2

        # Calculate where to place arrow head
        back = min(r + 5, dist - 10) if r else dist - 10
        ax, ay = x2 - ux * back, y2 - uy * back

        # Draw arrow head
        size = 6
        p1 = (ax + px * size, ay + py * size)
        p2 = (ax - px * size, ay - py * size)
        path = gc.CreatePath()
        path.MoveToPoint(x2 - ux * r, y2 - uy * r)
        path.AddLineToPoint(*p1)
        path.AddLineToPoint(*p2)
        path.CloseSubpath()
        gc.FillPath(path)

    def _find_node_at(self, x, y):
        for nid, (nx, ny) in self.node_positions.items():
            r = self.node_sizes.get(nid, 30) / 2
            if (x - nx) ** 2 + (y - ny) ** 2 <= r * r:
                return nid
        return None

    def _on_click(self, evt):
        x, y = evt.GetPosition()
        nid = self._find_node_at(x, y)
        if nid is not None:
            self.selected_id = nid
            self.view_btn.Enable()
            self._update_info()
        else:
            self.selected_id = None
            self.view_btn.Disable()
            self.info_label.SetLabel("No node selected")
        self.canvas.Refresh()

    def _on_double_click(self, evt):
        self._on_click(evt)
        if self.selected_id is not None:
            self._on_view(evt)

    def _update_info(self):
        # Get node if available
        node = self.node_map.get(self.selected_id)

        if node:
            # Count parents (nodes that have this node as child)
            parents = []
            for parent_id, parent in self.node_map.items():
                if self.selected_id in parent.children:
                    parents.append(parent_id)

            pcount = len(parents)
            ccount = len(node.children)

            node_type = node.type if hasattr(node, "type") else "unknown"
            self.info_label.SetLabel(
                f"Selected: {node.name} (Type: {node_type})\n"
                f"Connections: {pcount} parent(s), {ccount} child(ren)"
            )
        else:
            # Just ID information if we don't have the node object
            self.info_label.SetLabel(f"Selected: Node ID {self.selected_id}")

    def _on_view(self, evt):
        print("Looking up summary for node:", self.selected_id)
        if self.selected_id is None:
            return

        #  node = self.node_map.get(self.selected_id)
        # if not node:
        #     print("Not a node?")
        #     return

        msg = self.net.build_message(
            "GETSUMMARY",
            [
                str(
                    self.selected_id.id
                    if hasattr(self.selected_id, "id")
                    else self.selected_id
                )
            ],
        )
        self.net.send_message(msg)
        self.EndModal(wx.ID_OK)


// ----- HistoricList.py -----
import wx
import pickle
import base64
import datetime


class HistoricListFrame(wx.Frame):
    def __init__(self, parent, title, parsed, on_pick_callback=None):
        super().__init__(parent, title=title, size=(300, 400))
        panel = wx.Panel(self)
        self.on_pick_callback = on_pick_callback
        self.selected_datetime = None
        self.sorted_list = sorted(parsed)
        
        # Display strings
        display_list = [dt.strftime("%Y-%m-%d %H:%M:%S") for dt in self.sorted_list]
        
        # UI Elements
        self.list_box = wx.ListBox(panel, choices=display_list, style=wx.LB_SINGLE)
        pick_button = wx.Button(panel, label="Pick Timestamp")
        pick_button.Bind(wx.EVT_BUTTON, self.on_pick)
        
        # Layout
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.list_box, 1, wx.EXPAND | wx.ALL, 10)
        sizer.Add(pick_button, 0, wx.ALIGN_CENTER | wx.BOTTOM, 10)
        panel.SetSizer(sizer)
        
        self.Centre()
        self.Show()
        
    def on_pick(self, event):
        index = self.list_box.GetSelection()
        if index != wx.NOT_FOUND:
            self.selected_datetime = self.sorted_list[index]
            if self.on_pick_callback:
                self.on_pick_callback(self.selected_datetime)
            self.Close()


# Test function to handle the callback
def handle_timestamp_pick(selected_time):
    print(f"Selected timestamp: {selected_time}")
    print(f"Type: {type(selected_time)}")


if __name__ == "__main__":
    app = wx.App()
    
    # Create sample datetime objects
    current_time = datetime.datetime.now()
    sample_dates = [
        current_time - datetime.timedelta(days=10, hours=5),
        current_time - datetime.timedelta(days=7, hours=3),
        current_time - datetime.timedelta(days=5, hours=8),
        current_time - datetime.timedelta(days=3, hours=2),
        current_time - datetime.timedelta(days=1, hours=6),
        current_time
    ]
    
    # Create the frame with sample data
    frame = HistoricListFrame(
        None, 
        "Historic Timestamps", 
        sample_dates,
        on_pick_callback=handle_timestamp_pick
    )
    
    print("HistoricListFrame opened with sample data")
    print("Available timestamps:")
    for dt in sample_dates:
        print(f"  - {dt.strftime('%Y-%m-%d %H:%M:%S')}")
    print("\nSelect a timestamp and click 'Pick Timestamp' to see the callback in action")
    
    app.MainLoop()


// ----- login_frame.py -----
import wx
import pickle
import base64
from typing import List, Any, Tuple
import networkManager


def is_valid_password(password: str) -> bool:
    """At least 8 chars, at least one letter and one digit."""
    if len(password) < 8:
        return False
    if not any(c.isalpha() for c in password):
        return False
    if not any(c.isdigit() for c in password):
        return False
    return True


class LoginFrame(wx.Frame):
    def __init__(self, net: networkManager.NetworkManager):
        super().__init__(None, title="Login", size=(400, 300))
        self.net = net

        # -- Main panel & style --
        panel = wx.Panel(self)
        panel.SetBackgroundColour(wx.Colour(245, 245, 245))
        self.Centre()

        # -- Layout --
        vbox = wx.BoxSizer(wx.VERTICAL)

        # Title
        title = wx.StaticText(panel, label="Login to Your Account")
        title_font = wx.Font(14, wx.FONTFAMILY_SWISS, 
                              wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD)
        title.SetFont(title_font)
        vbox.Add(title, flag=wx.ALIGN_CENTER | wx.TOP, border=20)

        # Username
        vbox.AddStretchSpacer(1)
        vbox.Add(self._make_labeled_ctrl(panel, "Username:", wx.TextCtrl),
                 flag=wx.EXPAND | wx.LEFT | wx.RIGHT, border=40)
        vbox.AddStretchSpacer(1)

        # Password
        vbox.Add(self._make_labeled_ctrl(panel, "Password:", wx.TextCtrl, style=wx.TE_PASSWORD),
                 flag=wx.EXPAND | wx.LEFT | wx.RIGHT, border=40)
        vbox.AddStretchSpacer(1)

        # Buttons
        hbox = wx.BoxSizer(wx.HORIZONTAL)
        login_btn = wx.Button(panel, label="Login")
        register_btn = wx.Button(panel, label="Register")
        login_btn.Bind(wx.EVT_BUTTON, self.on_login)
        register_btn.Bind(wx.EVT_BUTTON, self.on_register)
        hbox.Add(login_btn, proportion=1, flag=wx.RIGHT, border=10)
        hbox.Add(register_btn, proportion=1)
        vbox.Add(hbox, flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.BOTTOM, border=40)
        vbox.AddStretchSpacer(2)

        panel.SetSizer(vbox)

    def _make_labeled_ctrl(self, parent, label, ctrl_cls, style=0):
        """Helper: returns a horizontal sizer with a label + control."""
        h = wx.BoxSizer(wx.HORIZONTAL)
        lbl = wx.StaticText(parent, label=label)
        ctrl = ctrl_cls(parent, style=style)
        setattr(self, label.lower().rstrip(":" ) + "_input", ctrl)
        h.Add(lbl, flag=wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, border=8)
        h.Add(ctrl, proportion=1)
        return h

    def on_login(self, event):
        username = self.username_input.GetValue()
        password = self.password_input.GetValue()

        # if not is_valid_password(password):
        #     wx.MessageBox(
        #         "Password must be at least 8 characters long\n"
        #         "and include both letters and digits.",
        #         "Invalid Password",
        #         wx.OK | wx.ICON_WARNING,
        #     )
        #     return

        success, events = self.authenticate(username, password)
        if success:
            wx.MessageBox("Login successful!", "Info",
                          wx.OK | wx.ICON_INFORMATION)
            self.open_main_frame(username, events)
        else:
            wx.MessageBox(
                "Login failed! Please check your credentials.",
                "Error",
                wx.OK | wx.ICON_ERROR,
            )

    def authenticate(self, username, password) -> Tuple[bool, List[Any]]:
        self.net.send_message(
            self.net.build_message("LOGIN", [username, password])
        )
        msg = self.net.recv_message()
        code = self.net.get_message_code(msg)
        params = self.net.get_message_params(msg)

        if "LOGIN_SUCCESS" in code:
            events = (
                [pickle.loads(base64.b64decode(x)) for x in params]
                if len(params) > 1 else []
            )
            return True, events
        return False, []

    def open_main_frame(self, username, events):
        self.Hide()
        from main_frame import MainFrame  # delay import
        main_frame = MainFrame(self.net, username)
        if events:
            main_frame.show_upcoming_events(events)
        main_frame.Show()

    def on_register(self, event):
        dlg = RegisterDialog(self.net)
        dlg.ShowModal()
        dlg.Destroy()


class RegisterDialog(wx.Dialog):
    def __init__(self, net: networkManager.NetworkManager):
        super().__init__(None, title="Register", size=(400, 350))
        self.net = net

        panel = wx.Panel(self)
        panel.SetBackgroundColour(wx.Colour(245, 245, 245))
        self.Centre()

        vbox = wx.BoxSizer(wx.VERTICAL)

        # Title
        title = wx.StaticText(panel, label="Create a New Account")
        title_font = wx.Font(14, wx.FONTFAMILY_SWISS, 
                              wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD)
        title.SetFont(title_font)
        vbox.Add(title, flag=wx.ALIGN_CENTER | wx.TOP, border=20)

        vbox.AddStretchSpacer(1)

        # Username / Password / Confirm
        vbox.Add(self._make_labeled_ctrl(panel, "Username:", wx.TextCtrl),
                 flag=wx.EXPAND | wx.LEFT | wx.RIGHT, border=40)
        vbox.AddStretchSpacer(1)
        vbox.Add(self._make_labeled_ctrl(panel, "Password:", wx.TextCtrl, style=wx.TE_PASSWORD),
                 flag=wx.EXPAND | wx.LEFT | wx.RIGHT, border=40)
        vbox.AddStretchSpacer(1)
        vbox.Add(self._make_labeled_ctrl(panel, "Confirm Password:", wx.TextCtrl, style=wx.TE_PASSWORD),
                 flag=wx.EXPAND | wx.LEFT | wx.RIGHT, border=40)

        vbox.AddStretchSpacer(2)

        # Register button
        reg_btn = wx.Button(panel, label="Register")
        reg_btn.Bind(wx.EVT_BUTTON, self.on_register)
        vbox.Add(reg_btn, flag=wx.ALIGN_CENTER | wx.ALL, border=20)

        panel.SetSizer(vbox)

    def _make_labeled_ctrl(self, parent, label, ctrl_cls, style=0):
        h = wx.BoxSizer(wx.HORIZONTAL)
        lbl = wx.StaticText(parent, label=label)
        ctrl = ctrl_cls(parent, style=style)
        attr = label.lower().rstrip(":" ).replace(" ", "_") + "_input"
        setattr(self, attr, ctrl)
        h.Add(lbl, flag=wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, border=8)
        h.Add(ctrl, proportion=1)
        return h

    def on_register(self, event):
        username = self.username_input.GetValue()
        password = self.password_input.GetValue()
        confirm = self.confirm_password_input.GetValue()

        if password != confirm:
            wx.MessageBox(
                "Passwords do not match!", "Error", wx.OK | wx.ICON_ERROR
            )
            return
        if not is_valid_password(password):
            wx.MessageBox(
                "Password must be at least 8 characters long\n"
                "and include both letters and digits.",
                "Invalid Password",
                wx.OK | wx.ICON_WARNING,
            )
            return

        self.net.send_message(
            self.net.build_message("REGISTER", [username, password])
        )
        msg = self.net.recv_message()
        code = self.net.get_message_code(msg)
        params = self.net.get_message_params(msg)

        if "REGISTER_SUCCESS" in code:
            wx.MessageBox(
                "Registration successful! You can now log in.",
                "Info", wx.OK | wx.ICON_INFORMATION
            )
            self.Close()
        else:
            wx.MessageBox(
                f"Registration failed: {params}",
                "Error", wx.OK | wx.ICON_ERROR
            )


if __name__ == "__main__":
    app = wx.App(False)
    net = networkManager.NetworkManager(None,None,None)
    login = LoginFrame(net)
    login.Show()
    app.MainLoop()



// ----- main_frame.py -----
import datetime
import wx
from networkManager import NetworkManager
import base64
import pickle
import os
import wx.html2
import wx.adv
import pdfkit
import time
import json
import difflib
import threading
import unicodedata
from GraphDial import GraphDialog
from EventDiag import EventsDialog
from FontDiag import FontSelectorDialog
from SummaryCarousell import SummaryCarousel
import traceback
from HistoricList import HistoricListFrame


class MainFrame(wx.Frame):
    def __init__(self, net: NetworkManager, username):
        super().__init__(None, title="App Dashboard", size=(800, 600))
        self.sock_lock = threading.Lock()
        self.listening_thread = threading.Thread(
            target=self.listen_for_changes, args=(self,), daemon=True
        )
        self.update_lock = threading.Lock()
        self.is_proccesing = threading.Event()
        # self.made_changes = []
        # Set up a timer to check for document changes
        self.update_timer = wx.Timer(self)
        self.update_enable_timer = wx.Timer(self)
        self.Bind(wx.EVT_TIMER, self.update_doc, self.update_timer)
        self.Bind(wx.EVT_TIMER, self.enable_listen, self.update_enable_timer)
        net.set_lock(self.sock_lock)
        self.net = net
        self.username = username
        self.listening_thread.start()
        self.html_content = ""  # To store HTML content
        self.awaiting_update = False
        self.cnt = 0 
        # Main panel
        panel = wx.Panel(self)
        self.last_char = ' '
        # Layout
        vbox = wx.BoxSizer(wx.VERTICAL)

        # Top controls (username, share button, see linked button, browse data button)
        hbox_top = wx.BoxSizer(wx.HORIZONTAL)
        self.username_label = wx.StaticText(panel, label=f"Username: {username}")
        share_button = wx.Button(panel, label="Share")
        see_linked_button = wx.Button(panel, label="See Linked")
        browse_data_button = wx.Button(panel, label="Browse Summaries")
        font_button = wx.Button(panel, label="Font Options")
        font_button.Bind(wx.EVT_BUTTON, self.on_font_selector)
        save_button = wx.Button(panel, label="Save")
        save_button.Bind(wx.EVT_BUTTON, self.on_save)
        graph_button = wx.Button(panel, label="See graph")
        history_button = wx.Button(panel, label="See History")
        history_button.Bind(wx.EVT_BUTTON, self.on_historic)
        hbox_top.Add(
            self.username_label,
            proportion=1,
            flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL,
            border=5,
        )
        hbox_top.Add(share_button, flag=wx.ALL, border=5)
        hbox_top.Add(see_linked_button, flag=wx.ALL, border=5)
        hbox_top.Add(browse_data_button, flag=wx.ALL, border=5)
        hbox_top.Add(font_button, flag=wx.ALL, border=5)
        hbox_top.Add(graph_button, flag=wx.ALL, border=5)
        hbox_top.Add(history_button, flag=wx.ALL, border=5)
        graph_button.Bind(wx.EVT_BUTTON, self.on_graph)
        # add_event_button = wx.Button(panel, label="Add Event")
        # add_event_button.Bind(wx.EVT_BUTTON, self.on_add_event)
        # hbox_top.Add(add_event_button, flag=wx.ALL, border=5)
        view_events_button = wx.Button(panel, label="View Events")
        view_events_button.Bind(wx.EVT_BUTTON, self.on_view_events)
        hbox_top.Add(view_events_button, flag=wx.ALL, border=5)
        vbox.Add(hbox_top, flag=wx.EXPAND | wx.ALL, border=10)

        # Split panel for editor and HTML view
        self.splitter = wx.SplitterWindow(panel, style=wx.SP_LIVE_UPDATE)

        # Text editor for input
        self.editor_panel = wx.Panel(self.splitter)
        editor_sizer = wx.BoxSizer(wx.VERTICAL)
        self.editor = wx.TextCtrl(self.editor_panel, style=wx.TE_MULTILINE)
        self.editor.Bind(wx.EVT_TEXT, self.on_text_input)
        self.editor.Bind(wx.EVT_CHAR, self.on_char)
        refresh_button = wx.Button(self.editor_panel, label="Refresh HTML View")
        refresh_button.Bind(wx.EVT_BUTTON, self.on_refresh_html)
        editor_sizer.Add(self.editor, proportion=1, flag=wx.EXPAND | wx.ALL, border=5)
        editor_sizer.Add(refresh_button, flag=wx.ALL, border=5)
        self.editor_panel.SetSizer(editor_sizer)

        # HTML display panel
        self.html_panel = wx.Panel(self.splitter)
        html_sizer = wx.BoxSizer(wx.VERTICAL)
        self.html_window = wx.html2.WebView.New(self.html_panel)
        self.html_window.Bind(wx.html2.EVT_WEBVIEW_NAVIGATING, self.on_link_clicked)
        html_sizer.Add(
            self.html_window, proportion=1, flag=wx.EXPAND | wx.ALL, border=5
        )
        self.html_panel.SetSizer(html_sizer)

        # Set up splitter
        self.splitter.SplitVertically(self.editor_panel, self.html_panel)
        self.splitter.SetSashPosition(400)

        vbox.Add(self.splitter, proportion=1, flag=wx.EXPAND | wx.ALL, border=10)

        # Bottom controls (Export, Import, Summarize)
        hbox_bottom = wx.BoxSizer(wx.HORIZONTAL)
        share_button.Bind(wx.EVT_BUTTON, self.share_summary)
        # Export button with dropdown
        export_button = wx.Button(panel, label="Export")
        export_button.Bind(wx.EVT_BUTTON, self.show_export_menu)
        hbox_bottom.Add(export_button, flag=wx.ALL, border=5)

        # Import button with dropdown
        import_button = wx.Button(panel, label="Import")
        import_button.Bind(wx.EVT_BUTTON, self.show_import_menu)
        hbox_bottom.Add(import_button, flag=wx.ALL, border=5)

        # Summarize button
        summarize_button = wx.Button(panel, label="Summarize with LLM")
        summarize_button.Bind(wx.EVT_BUTTON, self.on_summarize)
        hbox_bottom.Add(summarize_button, flag=wx.ALL, border=5)

        hbox_bottom.Add(save_button, flag=wx.ALL, border=5)
        vbox.Add(hbox_bottom, flag=wx.ALIGN_CENTER_HORIZONTAL | wx.ALL, border=10)

        # Set the main layout
        panel.SetSizer(vbox)

        # Bind browse data button
        browse_data_button.Bind(wx.EVT_BUTTON, self.on_browse_data)

        # Set default font info
        self.current_font = {"name": "Blackadder ITC", "url": None, "from_url": False}
        font = wx.Font(
            12,
            wx.FONTFAMILY_DEFAULT,
            wx.FONTSTYLE_NORMAL,
            wx.FONTWEIGHT_NORMAL,
            False,
            self.current_font["name"],
        )
        self.editor.SetFont(font)
        # Initialize HTML view
        self.prev_content = ""
        self.last_update_time = 0
        self.UPDATE_THROTTLE_INTERVAL = 2.0
        self.update_html_view()
        self.carousel = None
        self.events_dialog = None
        self.historic = False

    def on_graph(self, event):
        # print("Getting graph")
        if self.historic:
            self.net.send_message(
                self.net.build_message("HISTORICGRAPH", [str(self.picked_time)])
            )
            return
        self.net.send_message(self.net.build_message("GETGRAPH", []))

    def enable_listen(self, event):
        # self.awaiting_update = True
        pass

    def on_historic(self, event):
        self.net.send_message(self.net.build_message("GETHISTORICLIST", []))

    def handle_error(self, _, explaination, net):
        # wx.MessageBox(f"Error: {explaination}", "Error", wx.OK | wx.ICON_ERROR)
        wx.CallAfter(
            wx.MessageBox, f"Error: {explaination}", "Error", wx.OK | wx.ICON_ERROR
        )
        return

    def handle_take_summaries(self, _, *params, net):
        summaries = []
        for summary in params:
            summ = pickle.loads(base64.b64decode(summary))
            summaries.append(summ)

        def show_summaries():
            if not summaries:
                wx.MessageBox(
                    "No summaries found.", "Info", wx.OK | wx.ICON_INFORMATION
                )
                return

            # Show carousel
            self.carousel = SummaryCarousel(summaries, self.net, self)
            self.carousel.ShowModal()
            self.carousel.Destroy()
            # print("Removed caroussle")

        wx.CallAfter(show_summaries)

    def handle_take_events(self, _, *params, net):
        events = []
        for event_data in params:
            event = pickle.loads(base64.b64decode(event_data))
            events.append(event)

        def show_events():
            if not events:
                wx.MessageBox("No events found.", "Info", wx.OK | wx.ICON_INFORMATION)
                return
            if self.events_dialog:
                self.events_dialog.Destroy()

            # Show events dialog
            self.events_dialog = EventsDialog(events, self, self.net,debug=True)
            self.events_dialog.ShowModal()
            self.events_dialog.Destroy()
            self.events_dialog = None
        wx.CallAfter(show_events)

    def handle_event_success(self, *params, net):
        wx.CallAfter(
            wx.MessageBox,
            f"Event '{self.event_title}' on {self.formatted_date} at {self.formatted_time} added.",
            "Success",
            wx.OK | wx.ICON_INFORMATION,
        )
        wx.CallAfter(self.dialog.Destroy)

    def save_handlers(self, *params, net):
        print("Save, response: ", params)

    def on_file_content(self, *params, net):
        def update_editor():
            self.editor.AppendText("~".join(params[1:]))
            self.update_html_view()

        wx.CallAfter(update_editor)

    def handle_graph(self, _, *params, net):
        """Handle graph data received from server"""
        if not params:
            wx.CallAfter(
                wx.MessageBox, "No graph data received", "Error", wx.OK | wx.ICON_ERROR
            )
            return

        try:
            # Deserialize the graph data
            graph_data = pickle.loads(base64.b64decode(params[0]))

            # Make sure we display something even if the list is empty
            if not graph_data:
                wx.CallAfter(
                    wx.MessageBox,
                    "No summaries found in the graph. Try creating or sharing more summaries.",
                    "Empty Graph",
                    wx.OK | wx.ICON_INFORMATION,
                )
                return

            def show_graph():
                # Create and show the graph dialog
                graph_dialog = GraphDialog(self, graph_data, self.net)
                if graph_dialog.ShowModal() == wx.ID_OK:
                    # If user selected a node and closed with "View", content is already requested
                    pass
                graph_dialog.Destroy()

            wx.CallAfter(show_graph)

        except Exception as e:
            wx.CallAfter(
                wx.MessageBox,
                f"Error processing graph data: {str(e)}",
                "Error",
                wx.OK | wx.ICON_ERROR,
            )

    def on_summary_recived(self,s, *params, net):
        def update_summary():
            summ = params[0]
            start, end = self.editor.GetSelection()
            self.editor.Replace(start, end, summ)
            self.update_html_view()

        wx.CallAfter(update_summary)

    def listen_for_changes(self, *_):
        """Optimized listening thread with better error handling"""
        self.handlers = {
            "ERROR": self.handle_error,
            "TAKESUMMARIES": self.handle_take_summaries,
            "SAVE_SUCCESS": self.save_handlers,
            # "EVENT_SUCCESS": lambda a,*params,net: wx.CallAfter(wx.MessageBox,f'Event created successfully','Success',wx.OK | wx.ICON_INFORMATION),# self.handle_event_success,
            "FILECONTENT": self.on_file_content,
            "SUMMARY": self.on_summary_recived,
            "TAKEEVENTS": self.handle_take_events,
            "INFO": self.handle_info,
            "TAKEUPDATE": self.take_update,
            "SHARE_SUCCESS": lambda a, *params, net: wx.CallAfter(
                wx.MessageBox,
                f"Summary shared with {params[0]}",
                "Success",
                wx.OK | wx.ICON_INFORMATION,
            ),
            "TAKEHIST": self.handle_take_hist,
            "TAKESUMMARY": self.handle_recived_summary,
            "TAKEGRAPH": self.handle_graph,
            "TAKESUMMARYLINK": self.handle_take_link,
            "HISTORICLIST": self.get_historic_list,
        }

        self.net.add_handlers(self.handlers)
        self.net.sock.settimeout(0.5)
        while True:
            try:
                # Non-blocking receive with better error managementserver
                found_any = self.net.recv_handle_args(self)

                if not found_any:
                    time.sleep(0.1)  # Reduced sleep time

            except Exception as _:
                # print(f"Listening Thread Error: {e}")

                traceback.print_exc()
                time.sleep(1)  # Prevent tight error loop

    def share_summary(self, event):
        # print("Sharing summary")
        dialog = wx.TextEntryDialog(
            None, "Enter the username to share with:", "Share Summary"
        )
        if dialog.ShowModal() == wx.ID_OK:
            username = dialog.GetValue()
            # print("Sharing with: ", username)
            self.net.send_message(self.net.build_message("SHARESUMMARY", [username]))

        else:
            # print("Share canceled by user.")
            dialog.Destroy()
            return

    def show_upcoming_events(self, events):
        # Ensure all event dates are datetime.date
        for event in events:
            if isinstance(event["event_date"], datetime.datetime):
                # Convert datetime to date
                event["event_date"] = event["event_date"].date()

        # Sort events by proximity to current date
        sorted_events = sorted(
            events, key=lambda x: abs((x["event_date"] - datetime.date.today()).days)
        )

        # Create dialog
        dialog = wx.Dialog(self, title="Upcoming Events", size=(500, 400))
        panel = wx.Panel(dialog)

        vbox = wx.BoxSizer(wx.VERTICAL)

        # Events list
        events_list = wx.ListCtrl(panel, style=wx.LC_REPORT | wx.BORDER_SUNKEN)
        events_list.InsertColumn(0, "Title", width=200)
        events_list.InsertColumn(1, "Date", width=150)
        events_list.InsertColumn(2, "Days Away", width=120)

        for event in sorted_events:
            event_date = event["event_date"]  # Already converted to date
            days_away = (event_date - datetime.date.today()).days

            # Formatting label
            if days_away < 0:
                days_label = f"Happened {-days_away} days ago"
                color = wx.Colour(255, 0, 0)  # Red for past events
            elif days_away == 0:
                days_label = "Today"
                color = wx.Colour(0, 0, 255)  # Blue for today
            else:
                days_label = f"In {days_away} days"
                color = wx.Colour(0, 128, 0)  # Green for future events

            index = events_list.InsertItem(0, event["event_title"])
            events_list.SetItem(
                index, 1, event_date.strftime("%Y-%m-%d")
            )  # Convert date to string
            events_list.SetItem(index, 2, days_label)

            # Set text color
            for col in range(3):
                events_list.SetItemTextColour(index, color)

        vbox.Add(events_list, proportion=1, flag=wx.EXPAND | wx.ALL, border=10)

        # Continue button
        continue_button = wx.Button(panel, label="Continue")
        continue_button.Bind(wx.EVT_BUTTON, lambda event: dialog.EndModal(wx.ID_OK))
        vbox.Add(continue_button, flag=wx.ALIGN_CENTER | wx.ALL, border=10)

        panel.SetSizer(vbox)

        dialog.ShowModal()

    def is_update_throttled(self):
        """Check if an update should be throttled based on time since last update"""
        current_time = time.time()
        if current_time - self.last_update_time < self.UPDATE_THROTTLE_INTERVAL:
            return True
        self.last_update_time = current_time
        return False

    def normalize(self, text):
        text = unicodedata.normalize("NFC", text)  # Normalize unicode
        text = text.replace("\r\n", "\n").replace("\r", "").rstrip()
        return text

    def update_doc(self, event):
        # if self.awaiting_update:
        #     return #print("Awaiting update, not sending another")
        if self.is_proccesing.is_set():
            return  # print("Is proccesing, not sending another")
        if self.is_update_throttled():
            return
        if self.cnt < 3 and self.last_char != ' ':
            self.cnt += 1 
            return
        self.cnt = 0
        with self.update_lock:
            # old_text = self.prev_content
            # new_text = self.editor.GetValue()
            old_text = self.normalize(
                self.prev_content
            )  # self.prev_content.replace("\r\n", "\n").rstrip()
            new_text = self.normalize(
                self.editor.GetValue()
            )  # self.editor.GetValue().replace("\r\n", "\n").rstrip()
            # print(f"Old Text: {repr(old_text[:50])}")
            # print(f"New Text: {repr(new_text[:50])}")

            # Detect if content has actually changed
            if old_text == new_text:
                print("No Changes")
                return self.send_changes([], False)

            # Use advanced diff algorithm
            matcher = difflib.SequenceMatcher(None, old_text, new_text)
            changes = []

            for tag, i1, i2, j1, j2 in matcher.get_opcodes():
                if tag == "equal":
                    continue

                change_type = {
                    "replace": "UPDATE",
                    "delete": "DELETE",
                    "insert": "INSERT",
                }.get(tag, tag)

                content = new_text[j1:j2] if tag in ["replace", "insert"] else ""
                if content == "" and tag != "delete":
                    # print("Not a real change.")
                    continue
                changes.append({"cord": [i1, i2], "type": change_type, "cont": content})

            # Only send update if there are meaningful changes
            # if changes:
            self.send_changes(changes, new_text)

    def send_changes(self, changes, new_text):
        # print("Found these changes: ", changes)
        payload = json.dumps({"changes": changes})
        try:
            self.net.send_message(self.net.build_message("UPDATEDOC", [payload]))
            if new_text:
                self.prev_content = new_text
            self.awaiting_update = True
        except Exception as _:
            # print(f"Error sending update: {e}")
            traceback.print_exc()

    def handle_info(self, _, *params, net):
        # print("Recived info: ", params)
        wx.CallAfter(
            wx.MessageBox,
            f"Info: {params[0]}",
            "Info",
            wx.OK | wx.ICON_INFORMATION,
        )

    def get_historic_list(self, _, pickled, net):
        historic = pickle.loads(base64.b64decode(pickled))
        print("Historic: ", historic)
        # list of timestamps formated like this(str):  timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        # first paese the list, then sort
        parsed = [
            datetime.datetime.strptime(stamp, "%Y%m%d%H%M%S") for stamp in historic
        ]
        sorte = sorted(parsed)
        print(sorte)

        def create_frame(*_):
            frame = HistoricListFrame(
                self, "Historic List", sorte, self.on_historic_pick
            )
            frame.Show()
            # print("Showing historic list")

        wx.CallAfter(create_frame)

    def on_historic_pick(self, selected_datetime):
        print("Picked: ", selected_datetime)
        self.picked_time = selected_datetime
        self.load_historic(selected_datetime)

    def load_historic(self, selected_datetime):
        timestamp = selected_datetime.strftime("%Y%m%d%H%M%S")
        print("Loading: ", timestamp)
        self.net.send_message(self.net.build_message("LOADHISTORIC", [timestamp]))
        self.historic = True
        # print("Sent load historic message")

    def handle_take_link(self, _, link, net):
        # print("Requesting link with sid: ", link)
        self.net.send_message(self.net.build_message("GETSUMMARY", [link]))

    def take_update(self, _, *params, net):
        """Enhanced server update handler with input freezing"""
        try:
            # Indicate server update is in progress
            self.is_proccesing.set()

            # Decode update
            jsoned = json.loads(base64.b64decode(params[0]).decode())

            def update_ui():
                try:
                    # Disable editor during update
                    self.editor.Disable()

                    # Update content
                    new_content = jsoned["doc_content"]
                    self.editor.SetValue(new_content)
                    self.prev_content = new_content
                    self.update_html_view()

                    # Re-enable editor after short delay
                    wx.CallLater(500, self.editor.Enable)

                    # Clear update flags
                    self.awaiting_update = False
                    self.is_proccesing.clear()

                except Exception as _:
                    # print(f"UI Update Error: {e}")
                    self.editor.Enable()
                    self.is_proccesing.clear()

            # Ensure UI update happens on main thread
            wx.CallAfter(update_ui)

        except Exception as _:
            # print(f"Update Processing Error: {e}")
            traceback.print_exc()
            self.is_proccesing.clear()

    def on_font_selector(self, event):
        dialog = FontSelectorDialog(self, self.net)
        if dialog.ShowModal() == wx.ID_OK:
            font_name = dialog.selected_font
            from_url = dialog.from_url
            font_url = dialog.url_input.GetValue() if from_url else None
            font_path = dialog.custom_font_path if from_url else None

            # Store the selected font information
            self.current_font = {
                "name": font_name,
                "url": font_url,
                "from_url": from_url,
            }
            # print(self.current_font)
            # Apply the font to the editor
            font = wx.Font(
                12,
                wx.FONTFAMILY_DEFAULT,
                wx.FONTSTYLE_NORMAL,
                wx.FONTWEIGHT_NORMAL,
                False,
                font_name,
            )
            self.editor.SetFont(font)

            # If it's a custom font, upload it to the server
            if from_url and font_path:
                # self.upload_font_to_server(font_path, font_name, font_url)
                print("Uploading font to server")
            # Update the HTML view with the new font
            # self.send_update()
            self.update_html_view()

        dialog.Destroy()
    def on_char(self, event):
        keycode = event.GetKeyCode()
        if 32 <= keycode <= 126:  # Printable ASCII
            self.last_char = chr(keycode)
            print("Current char:", self.last_char)
        event.Skip()
    def on_text_input(self, event):
        # Store current position and content
        current_pos = self.editor.GetInsertionPoint()
        current_content = self.editor.GetValue()
        # Continue with existing functionality

        text_pos = current_pos - 1
        if text_pos < 2:
            return self.update_html_view()
        cont = current_content

        # Adjust for newlines
        text_pos -= 1 * cont.count("\n", 0, text_pos)
        if cont[text_pos] != "\n":
            # print("Re rendering")
            self.update_html_view()
            return
        prev_back_n = cont.rfind("\n", 0, text_pos - 1)
        if prev_back_n == -1:
            prev_back_n = 0
        # line = cont[prev_back_n:text_pos].strip()

        # if line.startswith("###"):
        # print("Found special line: ", line)
        # print("That's the special!!!!!!!!!!!")
        # print("Re rendering")
        self.update_html_view()

    def on_refresh_html(self, event):
        self.update_html_view()

    def update_html_view(self):
        """Convert text content to HTML and update the HTML window"""
        content = self.editor.GetValue()
        html = self.convert_text_to_html(content)
        self.html_content = html
        # self.html_window.RunScript(f"document.innerHTML = '{html}'")
        self.html_window.SetPage(html, "about:blank")

    def html_to_text(self, content):
        """Convert HTML back to text with special markup

        This function reverses the convert_text_to_html function by extracting
        text and special markup from HTML content.
        """
        import re
        from html import unescape

        # Initialize result
        result = []

        # Extract body content (ignore head, styles, etc.)
        body_match = re.search(r"<body>(.*?)</body>", content, re.DOTALL)
        if not body_match:
            return ""  # No body found

        body_content = body_match.group(1)

        # Process tables
        in_table = False

        # Use a simple state machine to process the content
        i = 0
        content_length = len(body_content)

        while i < content_length:
            # Check for table start
            if "<table>" in body_content[i : i + 10].lower():
                in_table = True
                result.append("###table")
                i += 7  # Length of <table>
                continue

            # Check for table end
            if in_table and "</table>" in body_content[i : i + 10].lower():
                in_table = False
                result.append("###endtable")
                i += 8  # Length of </table>
                continue

            # Process table rows
            if in_table and "<tr>" in body_content[i : i + 5].lower():
                row_cells = []
                i += 4  # Skip <tr>

                # Extract cells from this row
                while (
                    i < content_length
                    and "</tr>" not in body_content[i : i + 6].lower()
                ):
                    if "<td>" in body_content[i : i + 5].lower():
                        i += 4  # Skip <td>
                        cell_content = ""
                        while (
                            i < content_length
                            and "</td>" not in body_content[i : i + 6].lower()
                        ):
                            cell_content += body_content[i]
                            i += 1
                        i += 5  # Skip </td>
                        row_cells.append(cell_content.strip())
                    else:
                        i += 1

                # Join cells with pipe symbol
                if row_cells:
                    result.append(" | ".join(row_cells))

                # Skip past </tr>
                while (
                    i < content_length
                    and "</tr>" not in body_content[i : i + 6].lower()
                ):
                    i += 1
                i += 5  # Skip </tr>
                continue

            # Process links
            if '<a href="internal:' in body_content[i : i + 20].lower():
                link_start = i + 16  # Position after 'internal:'
                link_end = body_content.find('">', i)
                if link_end != -1:
                    link_text = body_content[link_start:link_end]
                    result.append(f"###link {link_text}")
                    i = body_content.find("</a>", link_end) + 4
                    continue

            # Process bold text
            if "<span class='bold'>" in body_content[i : i + 20].lower():
                result.append("###bold")
                i += 19  # Length of <span class='bold'>
                continue

            if "</span>" in body_content[i : i + 10].lower() and "###bold" in result:
                result.append("###unbold")
                i += 7  # Length of </span>
                continue

            # Process paragraphs
            if "<p>" in body_content[i : i + 5].lower():
                i += 3  # Skip <p>
                para_content = ""
                while (
                    i < content_length and "</p>" not in body_content[i : i + 5].lower()
                ):
                    para_content += body_content[i]
                    i += 1
                i += 4  # Skip </p>

                # Reverse the &nbsp; replacement
                para_content = para_content.replace("&nbsp;", " ")

                # Unescape HTML entities
                para_content = unescape(para_content)

                result.append(para_content)
                continue

            # Move to next character if no patterns matched
            i += 1

        # Join all lines with newlines
        return "\n".join(result)

    def convert_text_to_html(self, content):
        """Convert text with special markup to HTML"""
        html = [
            "<!DOCTYPE html><html><head>",
            "<style>",
            "table { border-collapse: collapse; width: 100%; }",
            "th, td { border: 4px solid #000; padding: 8px; }",
            "th { background-color: #f2f2f2; }",
            "a { color: blue; text-decoration: underline; cursor: pointer; }",
            ".bold { font-weight: bold; }",
        ]

        # Handle font setup - either from URL or system font
        if self.current_font["from_url"] and self.current_font["url"]:
            # For web fonts, use @font-face declaration
            font_url = self.current_font["url"]
            font_name = self.current_font["name"]
            # Remove any invalid characters from font name
            font_name = font_name.replace("|", "")

            html.append("@font-face {{")
            html.append(f"  font-family: '{font_name}';")
            html.append(f"  src: url('{font_url}');")
            html.append("}}")
            html.append(
                f"body {{ font-family: '{font_name}', sans-serif; margin: 20px; }}"
            )
        else:
            # For system fonts, just set the font-family
            font_name = self.current_font["name"].replace("|", "")  # .replace("@","")
            html.append(
                f"body {{ font-family: '{font_name}', sans-serif; margin: 20px; }}"
            )

        html.append("</style></head><body>")
        # print("Styling info: ", html)
        lines = content.split("\n")
        i = 0
        in_table = False
        table_html = []

        while i < len(lines):
            line = lines[i].strip()

            # Handle special commands
            if line.startswith("###"):
                cmd = line[3:].strip()

                if cmd.startswith("table"):
                    in_table = True
                    table_html = ["<table>"]
                    # Table header can be added here if needed

                elif cmd.startswith("endtable") and in_table:
                    in_table = False
                    table_html.append("</table>")
                    html.append("".join(table_html))

                elif cmd.startswith("link"):
                    # Extract link target
                    link_text = line[7:].strip()  # preserve case
                    html.append(f'<a href="internal:{link_text}">{link_text}</a>')

                elif cmd.startswith("bold"):
                    html.append("<span class='bold'>")

                elif cmd.startswith("unbold"):
                    html.append("</span>")

                # Other commands can be handled similarly

            else:
                # Regular text - handle paragraphs
                if in_table:
                    # Add to table if we're in a table context
                    # This is simplified - you'd need more logic for proper tables
                    cells = line.split("|")
                    if len(cells) > 1:
                        table_html.append("<tr>")
                        for cell in cells:
                            table_html.append(f"<td>{cell.strip()}</td>")
                        table_html.append("</tr>")
                else:
                    # Regular paragraph
                    if line:
                        # Replace spaces with &nbsp; for preserving multiple spaces
                        formatted_line = line.replace("  ", " &nbsp;")
                        html.append(f"<p>{formatted_line}</p>")
                # if not in_table and line == "":
                #     html.append("<br>")
            # html += "<br>"
            i += 1

        html.append("</body></html>")
        # print("".join(html))
        # #print(html)
        return "".join(html)

    def on_link_clicked(self, event):
        link = event.GetURL()
        if link.startswith("data:"):
            return
        # print(f"Link clicked: {link}")
        if link.startswith("internal:"):
            name = link[len("internal:") :]
            self.net.send_message(self.net.build_message("GETSUMMARYLINK", [name]))
            # print("Sent get summary message")
            cont = base64.b64decode(
                self.net.get_message_params(self.net.recv_message())[0]
            ).decode()
            # print("THE CONTENT: ", cont)
            self.editor.SetValue(cont)
            self.prev_content = cont
            self.update_html_view()

        # if link.startswith("internal:"):
        #     target = link[9:]  # Remove 'internal:' prefix
        #     wx.MessageBox(
        #         f"Navigating to internal section: {target}",
        #         "Link Clicked",
        #         wx.OK | wx.ICON_INFORMATION,
        #     )
        #     event.Veto()  # Prevent navigation if needed
        # else:
        #     # Open external links in the default browser
        #     wx.LaunchDefaultBrowser(link)

    def on_summarize(self, event):
        selected = self.editor.GetStringSelection()
        # print("Currently selecting : ", selected)
        self.net.send_message(self.net.build_message("SUMMARIZE", [selected]))

    def show_export_menu(self, event):
        # print("Showing export menu")
        menu = wx.Menu()
        for label, handler in [
            ("Markdown", self.export_as_markdown),
            ("PDF", self.export_as_pdf),
            ("HTML", self.export_as_html),
            ("TXT", self.export_as_txt),
        ]:
            item = wx.MenuItem(menu, wx.ID_ANY, label)
            menu.Bind(wx.EVT_MENU, handler, id=item.GetId())
            menu.Append(item)
        self.PopupMenu(menu)

    def show_import_menu(self, event):
        # print("Showing import menu")
        menu = wx.Menu()
        for label, handler in [
            ("Markdown", self.import_from_markdown),
            # ("PDF", self.import_from_pdf),
            ("HTML", self.import_from_html),
            ("TXT", self.import_from_txt),
            ("Scan A File", self.import_from_file),
        ]:
            item = wx.MenuItem(menu, wx.ID_ANY, label)
            menu.Bind(wx.EVT_MENU, handler, id=item.GetId())
            menu.Append(item)
        self.PopupMenu(menu)

    def import_from_file(self, event):
        # Open a file dialog to select a File
        dialog = wx.FileDialog(
            self,
            message="Choose a file to import",
            style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST,
        )
        if dialog.ShowModal() == wx.ID_CANCEL:
            return
        path = dialog.GetPath()
        self.net.send_file(path)
        self.net.send_message(
            self.net.build_message("GETFILECONTENT", [os.path.basename(path)])
        )

    def on_view_events(self, event):
        self.net.send_message(self.net.build_message("GETEVENTS", []))

    def on_add_event(self, event):
        dialog = wx.Dialog(self, title="Add New Event", size=(400, 300))
        panel = wx.Panel(dialog)

        # Vertical layout for the dialog
        vbox = wx.BoxSizer(wx.VERTICAL)

        # Title input
        title_label = wx.StaticText(panel, label="Event Title:")
        title_input = wx.TextCtrl(panel)
        vbox.Add(title_label, flag=wx.ALL, border=5)
        vbox.Add(title_input, flag=wx.EXPAND | wx.ALL, border=5)

        # Date input
        date_label = wx.StaticText(panel, label="Event Date:")
        date_picker = wx.adv.DatePickerCtrl(
            panel, style=wx.adv.DP_DEFAULT | wx.adv.DP_SHOWCENTURY
        )
        vbox.Add(date_label, flag=wx.ALL, border=5)
        vbox.Add(date_picker, flag=wx.EXPAND | wx.ALL, border=5)

        # Time input
        time_label = wx.StaticText(panel, label="Event Time:")
        time_picker = wx.adv.TimePickerCtrl(panel, style=wx.adv.TP_DEFAULT)
        vbox.Add(time_label, flag=wx.ALL, border=5)
        vbox.Add(time_picker, flag=wx.EXPAND | wx.ALL, border=5)

        # Buttons
        button_sizer = wx.StdDialogButtonSizer()
        ok_button = wx.Button(panel, wx.ID_OK)
        ok_button.SetDefault()
        cancel_button = wx.Button(panel, wx.ID_CANCEL)

        button_sizer.AddButton(ok_button)
        button_sizer.AddButton(cancel_button)
        button_sizer.Realize()

        vbox.Add(button_sizer, flag=wx.ALIGN_CENTER | wx.ALL, border=10)

        panel.SetSizer(vbox)

        # Show the dialog and handle result
        if dialog.ShowModal() == wx.ID_OK:
            self.event_title = title_input.GetValue()
            self.event_date = date_picker.GetValue()
            self.event_time = time_picker.GetValue()

            # Validate inputs
            if not self.event_title:
                wx.MessageBox(
                    "Please enter an event title.", "Error", wx.OK | wx.ICON_ERROR
                )
                dialog.Destroy()
                return

            # Convert wx date and time to Python date and time
            self.formatted_date = self.event_date.FormatISODate()
            self.formatted_time = self.event_time.Format("%H:%M:%S")
            self.datetime_str = f"{self.formatted_date} {self.formatted_time}"

            self.net.send_message(
                self.net.build_message(
                    "ADDEVENT", [self.event_title, self.datetime_str]
                )
            )
            self.dialog = dialog
            # might be better to create the handler dynamically here, rather than have all state in the class

    def export_as_markdown(self, event):
        # print("Exporting as Markdown")
        self.export_file("md")

    def export_as_pdf(self, event):
        # print("Exporting as PDF")
        self.export_file("pdf")

    def export_as_html(self, event):
        # print("Exporting as HTML")
        # For HTML, we could directly use our HTML content
        self.export_file("html", use_html=True)

    def export_as_txt(self, event):
        # print("Exporting as TXT")
        self.export_file("txt")

    def export_file(self, ext, use_html=False):
        dialog = wx.FileDialog(
            self,
            message="Save file as ...",
            defaultDir=os.getcwd(),
            defaultFile=f"summary.{ext}",
            wildcard=f"{ext.upper()} files (*.{ext})|*.{ext}",
            style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT,
        )
        if dialog.ShowModal() == wx.ID_CANCEL:
            return
        path = dialog.GetPath()
        dialog.Destroy()

        # # For HTML export, we can use our already formatted HTML content
        # content = (
        #     self.html_content if use_html and ext == "html" else self.editor.GetValue()
        # )
        #
        # self.net.send_message(self.net.build_message("EXPORT", [content, ext]))
        # inner_content = self.net.get_message_params(self.net.recv_message())[0]
        if ext.lower() == "pdf":
            # gross ill rewrite with all the rest

            return pdfkit.from_string(self.html_content, path)
        formated_content = self.format_content(self.editor.GetValue(), ext)
        # print("Writing: ", formated_content)
        with open(path, "w") as f:
            f.write(formated_content)
        # with open(path, "wb") as f:
        #     f.write(base64.b64decode(inner_content))
        wx.MessageBox(
            f"Summary saved to {path}", "Export Successful", wx.OK | wx.ICON_INFORMATION
        )

    def format_content(self, content, ext):
        if ext.lower() == "html":
            # print("HTML")
            # print(self.html_content)
            self.on_refresh_html(None)
            return self.html_content
        # elif ext == "md" or ext == "txt":
        #     return content
        elif ext.lower() == "pdf":
            self.on_refresh_html(None)
            return self.html_content
        return content

    def import_from_markdown(self, event):
        # print("Importing from Markdown")
        file_text_content = self.get_file_content("md")
        if not file_text_content:
            return
        self.editor.SetValue(file_text_content)
        self.update_html_view()

    def import_from_pdf(self, event):
        print("Importing from PDF")
        # Implementation would go here

    def import_from_html(self, event):
        # print("Importing from HTML")
        # Implementation would go here
        file_text_content = self.get_file_content("html")
        if not file_text_content:
            return
        # preform the reverse of convert_text_to_html
        self.editor.SetValue(self.html_to_text(file_text_content))
        self.update_html_view()
        return

    def import_from_txt(self, event):
        # print("Importing from TXT")
        # Implementation would go here
        file_text_content = self.get_file_content("txt")
        if not file_text_content:
            return
        self.editor.SetValue(file_text_content)
        self.update_html_view()

    def get_file_content(self, ext):
        # Open a file dialog to select a File
        # return its text content for txt and md
        # returns its html for pdf and html
        dialog = wx.FileDialog(
            self,
            message="Choose a file to import",
            style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST,
        )
        if dialog.ShowModal() == wx.ID_CANCEL:
            return
        path = dialog.GetPath()
        # if path.endswith(".pdf"):
        #     return self.get_pdf_content(path)
        dialog.Destroy()
        with open(path, "r") as f:
            return f.read()

    # def get_pdf_content(self, path):
    #     # convert pdf to html using pdfkit
    #     return pdfkit.
    def on_browse_data(self, event):
        wx.MessageBox(
            f"Browsing data for user: {self.username}",
            "Info",
            wx.OK | wx.ICON_INFORMATION,
        )
        self.net.send_message(self.net.build_message("GETSUMMARIES", []))
        msg = self.net.recv_message()
        code, params = self.net.get_message_code(msg), self.net.get_message_params(msg)
        if code.strip() == "ERROR":
            wx.MessageBox(f"Error: {params[0]}", "Error", wx.OK | wx.ICON_ERROR)
            return
        #
        summaries = []
        for summary in params:
            summ = pickle.loads(base64.b64decode(summary))
            summaries.append(summ)

        if not summaries:
            wx.MessageBox("No summaries found.", "Info", wx.OK | wx.ICON_INFORMATION)
            return

        # Show carousel
        carousel = SummaryCarousel(summaries, self.net, self)
        carousel.ShowModal()
        carousel.Destroy()

    def on_save(self, event):
        # print("Saving")

        # Prompt the user for a title
        dialog = wx.TextEntryDialog(
            None, "Enter a title for the summary:", "Save Summary"
        )
        if dialog.ShowModal() == wx.ID_OK:
            title = dialog.GetValue()
        else:
            # print("Save canceled by user.")
            dialog.Destroy()
            return  # Exit if the user cancels the input

        dialog.Destroy()

        # Build and send the save message with font information
        font_info = {
            "name": self.current_font["name"],
            "url": self.current_font["url"] if self.current_font["from_url"] else "",
        }

        # Convert font info to string
        font_info_str = f"{font_info['name']}|{font_info['url']}"

        # Build and send the save message
        self.net.send_message(
            self.net.build_message(
                "SAVE", [title, self.editor.GetValue(), font_info_str]
            )
        )

    def handle_take_hist(self, _, *params, net):
        self.historic = True

        def process_summary():
            try:
                dic = pickle.loads(base64.b64decode(params[0]))
                cont = dic["data"].decode()
                dicty = {"font": dic["summ"].font}
                self.editor.SetValue(cont)
                self.prev_content = cont
                dicty["font"] = dicty.get("font", "Arial")

                if dicty["font"] and dicty["font"].startswith("http"):
                    self.current_font = {
                        "name": dicty["font"],
                        "url": dicty["font"],
                        "from_url": True,
                    }
                else:
                    # Clean up the font name - remove any @ symbol or pipe characters
                    if dicty.get("font") is None:
                        clean_font_name = "Arial"

                    else:
                        clean_font_name = (
                            dicty.get("font", "Arial").replace("@", "").replace("|", "")
                        )
                    self.current_font = {
                        "name": clean_font_name if clean_font_name else "Arial",
                        "url": None,
                        "from_url": False,
                    }

                try:
                    font = wx.Font(
                        12,
                        wx.FONTFAMILY_DEFAULT,
                        wx.FONTSTYLE_NORMAL,
                        wx.FONTWEIGHT_NORMAL,
                        False,
                        self.current_font["name"],
                    )
                    self.editor.SetFont(font)
                except Exception as font_error:
                    print(f"Error setting font: {font_error}")
                    # Fallback to default font
                    default_font = wx.Font(
                        12,
                        wx.FONTFAMILY_DEFAULT,
                        wx.FONTSTYLE_NORMAL,
                        wx.FONTWEIGHT_NORMAL,
                        False,
                        "Arial",
                    )
                    self.editor.SetFont(default_font)

                print("Font info: ", self.current_font)
                self.update_timer.Stop()
                self.update_enable_timer.Stop()
                # if hasattr(self, "carousel") and self.carousel:
                #     self.carousel.Close()
                # self.update_timer.Start(3000)  # Check every 3 seconds
                # self.update_enable_timer.Start(3000)
            except Exception as _:
                # print("Error: ", e)
                traceback.print_exc()
                wx.MessageBox(
                    "Error: Could not retrieve summary content.",
                    "Error",
                    wx.OK | wx.ICON_ERROR,
                )
                self.Close()

        wx.CallAfter(process_summary)

    def handle_recived_summary(self, _, *params, net):
        self.historic = False

        def process_summary():
            try:
                dic = pickle.loads(base64.b64decode(params[0]))
                cont = dic["data"].decode()
                dicty = {"font": dic["summ"].font}
                self.editor.SetValue(cont)
                self.prev_content = cont
                dicty["font"] = dicty.get("font", "Arial")

                if dicty["font"] and dicty["font"].startswith("http"):
                    self.current_font = {
                        "name": dicty["font"],
                        "url": dicty["font"],
                        "from_url": True,
                    }
                else:
                    # Clean up the font name - remove any @ symbol or pipe characters
                    if dicty.get("font") is None:
                        clean_font_name = "Arial"

                    else:
                        clean_font_name = (
                            dicty.get("font", "Arial").replace("@", "").replace("|", "")
                        )
                    self.current_font = {
                        "name": clean_font_name if clean_font_name else "Arial",
                        "url": None,
                        "from_url": False,
                    }

                try:
                    font = wx.Font(
                        12,
                        wx.FONTFAMILY_DEFAULT,
                        wx.FONTSTYLE_NORMAL,
                        wx.FONTWEIGHT_NORMAL,
                        False,
                        self.current_font["name"],
                    )
                    self.editor.SetFont(font)
                except Exception as font_error:
                    print(f"Error setting font: {font_error}")
                    # Fallback to default font
                    default_font = wx.Font(
                        12,
                        wx.FONTFAMILY_DEFAULT,
                        wx.FONTSTYLE_NORMAL,
                        wx.FONTWEIGHT_NORMAL,
                        False,
                        "Arial",
                    )
                    self.editor.SetFont(default_font)

                print("Font info: ", self.current_font)
                if hasattr(self, "carousel") and self.carousel:
                    self.carousel.Close()
                self.update_timer.Start(3000)  # Check every 3 seconds
                self.update_enable_timer.Start(3000)
            except Exception as _:
                # print("Error: ", e)
                traceback.print_exc()
                wx.MessageBox(
                    "Error: Could not retrieve summary content.",
                    "Error",
                    wx.OK | wx.ICON_ERROR,
                )
                self.Close()

        wx.CallAfter(process_summary)


// ----- networkManager.py -----
import base64
from socket import socket
from typing import Callable, Dict, List
import select
import time
import os
from cryptManager import CryptManager
import threading


class NetworkManager:
    """
    A class to manage socket communication, build and parse messages, and handle incoming messages
    with custom handlers for specific message codes.
    """

    def __init__(
        self, sock: socket, crypt: CryptManager, handlers: Dict[str, Callable]
    ) -> None:
        """
        Initialize the SocketHandler class.

        :param sock: A socket object representing the connection.
        """
        self.sock = sock
        self.handlers: Dict[str, Callable] = handlers
        self.crypt_manager = crypt
        self.lock = threading.Lock()

    def _get_file_name(self, path: str) -> str:
        return os.path.basename(path)

    def send_file(self, path) -> None:
        name = self._get_file_name(path)
        self.send_message(self.build_message("FILE", [name], False))
        with open(path, "rb") as f:
            # read chunk of 1024 at a time
            chunk = f.read(1024)
            while chunk:
                self.send_message(
                    self.build_message(
                        "CHUNK", [name, base64.b64encode(chunk).decode()], False
                    )
                )
                chunk = f.read(1024)
        print("Finished chunking the file")
        self.send_message(self.build_message("END", [name], False))

    def build_message(self, code: str, params: List[str], do_size=False) -> str:
        """
        Build a formatted message string with a code and parameters.

        :param code: The message code.
        :param params: A list of parameters to include in the message.
        :return: A formatted message string.
        """
        payload = code + "~" + "~".join(params)
        return (f"{len(payload):10}" if do_size else "") + f"{payload}"

    def send_message_plain(self, message: str) -> None:
        """

        Send a message over the socket connection.

        :param message: The message string to send.
        """
        with self.lock:
            print(f"SEND>>>{message[: min(100, len(message))]}")
            self.sock.send(message.encode())

    def has_received(self) -> bool:
        """
        Check if a new message has been received.

        :return: True if a new message is available, otherwise False.
        """
        with self.lock:
            return self.sock in select.select([self.sock], [], [], 0)[0]

    def recv_handle(self) -> None:
        """
        Receive a message from the socket connection and handle it with the appropriate handler function.
        """
        try:
            if not self.has_received():
                # print("No message received.")
                return
            message = self.recv_message()
            code = self.get_message_code(message)
            if code in self.handlers.keys():
                print("Recived code: ", code)
                self.handlers[code](*self.get_message_params(message), net=self)
            else:
                print(f"Received message with unhandled code: {code}")
                return True
        # ConnectionResetError
        except ConnectionResetError:
            print("Connection reset by peer.")
            return True

    def recv_handle_server(self, *args) -> None:
        """
        Receive a message from the socket connection and handle it with the appropriate handler function.
        """
        try:
            if not self.has_received():
                # print("No message received.")
                return
            message = self.recv_message()
            code = self.get_message_code(message)
            if code in self.handlers.keys():
                print("Recived code: ", code)
                self.handlers[code](*args, *self.get_message_params(message), net=self)
            else:
                print(f"Received message with unhandled code: {code}")
                return True
        # ConnectionResetError
        except ConnectionResetError:
            print("Connection reset by peer.")
            return True

    def recv_handle_args(self, *args) -> bool:
        """
        Receive a message from the socket connection and handle it with the appropriate handler function.
        """
        if not self.has_received():
            # print("Received message.")
            # print("No message received.")
            return False
        message = self.recv_message()
        code = self.get_message_code(message)
        if code in self.handlers.keys():
            print("Recived code: ", code)
            self.handlers[code](*args, *self.get_message_params(message), net=self)
            return True
        else:
            print(f"Received message with unhandled code: {code}")
            print("Current codes:", self.handlers.keys())
            raise Exception("Unhandled code.")

    def set_lock(self, lock):
        self.lock = lock

    def wait_recv(self) -> None:
        """
        Wait for a message to be received, then handle it automatically.
        """
        while not self.has_received():
            time.sleep(0.1)
        return self.recv_handle()

    def add_handler(self, code: str, handler: Callable) -> None:
        """
        Add a handler function for a specific message code.

        :param code: The message code.
        :param handler: A callable function to handle messages with the specified code.
        """
        self.handlers[code] = handler

    def add_handlers(self, handlers: Dict[str, Callable]) -> None:
        """
        Add multiple handlers for different message codes.

        :param handlers: A dictionary of message codes and their respective handlers.
        """
        self.handlers.update(handlers)

    def get_message_code(self, message: str) -> str:
        """
        Extract the message code from a message string.

        :param message: The message string.
        :return: The extracted message code.
        """
        return message[: message.index("~")]

    def get_message_params(self, message: str) -> List[str]:
        """
        Extract the parameters from a message string.

        :param message: The message string.
        :return: A list of extracted parameters.
        """
        return message[message.index("~") + 1 :].split("~")

    def recv_message(self):
        """
        Receive a message from the socket connection.

        :return: The received message string.
        """
        # message = self.sock.recv(10).decode()

        message = self.recv_message_plain()
        payload, iv = self.get_message_params(message.decode())
        #  print(f"DECODING WITH: {iv} \n {self.crypt_manager.aes_key}")
        msg = self.crypt_manager.decrypt_data(
            base64.b64decode(payload), base64.b64decode(iv)
        ).decode()
        print("DECODE TO: ", msg[: min(60, len(msg))])
        return msg

    def recv_message_plain(self):
        size = b""
        with self.lock:
            while len(size) < 10:
                size += self.sock.recv(10 - len(size))
            size_int = int(size.decode())
            message = b""
            while len(message) < size_int:
                try:
                    message += self.sock.recv(size_int - len(message))
                except ConnectionResetError:
                    print("Connection reset by peer.")
                    return ""
                # except:
                #     print("Socket timeout.")
                except Exception as e:
                    print("Error: ", e)
                    # return ""
                    print("Socket timeout.")

            print(f"RECV>>>{size}{message[:30]}")
            return message

    def send_message(self, message: str) -> None:
        """
        Send a message over the socket connection.

        :param message: The message string to send.
        """
        #  print("ENCRYPTING WITH: ", self.crypt_manager.aes_key)
        arr = [
            base64.b64encode(d).decode()
            for d in self.crypt_manager.encrypt_data(message.encode())
        ]
        if self.lock:
            with self.lock:
                # print("IV: ", arr[1])
                print("Using lock.")
                self.sock.send(
                    self.build_message("ENCODED", arr, do_size=True).encode()
                )
                print(f"SEND>>>{message[: min(100, len(message))]}")
        else:
            self.sock.send(self.build_message("ENCODED", arr, do_size=True).encode())
            print(f"SEND>>>{message[: min(100, len(message))]}")

# Place this at the bottom of your file or in a separate test file

import pytest
from unittest.mock import Mock, MagicMock
import base64

# === Sample Mock CryptManager ===
class MockCryptManager:
    def __init__(self):
        self.aes_key = b"mockkey123456789"

    def encrypt_data(self, data: bytes):
        return (data[::-1], b"mockiv")

    def decrypt_data(self, data: bytes, iv: bytes):
        return data[::-1]


@pytest.fixture
def mock_sock():
    sock = Mock()
    sock.recv = MagicMock(side_effect=[
        b"0000000032",  # Length prefix (32 bytes)
        b"ENCODED~" + base64.b64encode(b"test")[::-1] + b"~" + base64.b64encode(b"mockiv")
    ])
    sock.send = MagicMock()
    return sock


@pytest.fixture
def net_mgr(mock_sock):
    return NetworkManager(
        sock=mock_sock,
        crypt=MockCryptManager(),
        handlers={}
    )


# === Unit Tests ===

def test_build_message_without_size(net_mgr):
    msg = net_mgr.build_message("CODE", ["param1", "param2"])
    assert msg == "CODE~param1~param2"


def test_build_message_with_size(net_mgr):
    msg = net_mgr.build_message("CMD", ["x", "y"], do_size=True)
    assert msg.startswith("        ")  # 10 space-padded chars for length
    assert "CMD~x~y" in msg


def test_get_file_name(net_mgr):
    assert net_mgr._get_file_name("/some/path/file.txt") == "file.txt"


def test_get_message_code_and_params(net_mgr):
    msg = "CODE~arg1~arg2~arg3"
    assert net_mgr.get_message_code(msg) == "CODE"
    assert net_mgr.get_message_params(msg) == ["arg1", "arg2", "arg3"]


def test_send_message_encodes_correctly(net_mgr, mock_sock):
    net_mgr.send_message("hello world")
    args = mock_sock.send.call_args[0][0]
    assert isinstance(args, bytes)
    assert b"ENCODED" in args


def test_recv_message_decodes_correctly(net_mgr):
    # We will override recv_message_plain to return a known encoded message
    encoded = net_mgr.build_message("ENCODED", [
        base64.b64encode(b"dlrow olleh").decode(),  # reversed 'hello world'
        base64.b64encode(b"mockiv").decode()
    ], do_size=False).encode()

    net_mgr.recv_message_plain = lambda: encoded
    result = net_mgr.recv_message()
    assert result == "hello world"


def test_add_handler_and_call(net_mgr):
    called = {}

    def mock_handler(p1, net=None):
        called['p1'] = p1

    net_mgr.add_handler("TEST", mock_handler)
    net_mgr.handlers["TEST"]("value", net=net_mgr)
    assert called['p1'] == "value"


def test_add_handlers_bulk(net_mgr):
    h1 = lambda: None
    h2 = lambda: None
    net_mgr.add_handlers({"A": h1, "B": h2})
    assert net_mgr.handlers["A"] == h1
    assert net_mgr.handlers["B"] == h2


# === Colored CLI Runner ===
if __name__ == "__main__":
    import sys
    sys.exit(pytest.main(["-v", "--color=yes", "--tb=short"]))





// ----- OCRManager.py -----
import pytest
import sys
import os
import time
import random
import numpy as np
from termcolor import colored
from unittest.mock import patch
import tempfile
from PIL import Image, ImageDraw, ImageFont
import io
from sumy.utils import get_stop_words
from sumy.nlp.stemmers import Stemmer
# Use a simpler summarizer like Luhn for faster testing if LSA or Transformers are too slow/heavy
# from sumy.summarizers.luhn import LuhnSummarizer
from sumy.summarizers.lsa import LsaSummarizer # Keeping LSA as in original
from sumy.nlp.tokenizers import Tokenizer
from sumy.parsers.plaintext import PlaintextParser
import pytesseract # Make sure Tesseract is installed and in PATH

# --- Configuration ---
SAMPLE_TEXT = """This benchmark evaluates AI models on accuracy, speed, and efficiency across various tasks such as image recognition, natural language understanding, and reasoning.
It includes standardized datasets and scoring metrics to ensure fair comparisons between models.
The goal is to identify strengths, weaknesses, and suitability of models for real-world applications."""

# Simulate having multiple test images with varying simple text
NUM_SIMULATED_IMAGES = 5 # Reduced from 10 for faster testing
SIMULATED_BENCHMARK_TEXTS = [
    f"Benchmark image. Contains standard test patterns.",
    f"Simple text for OCR testing, case.",
    f"Image recognition task input.",
]

# --- Core Functions (Unchanged) ---
HAS_SHITTONE_OF_RAM = False # Keep this flag, though the test skips the transformer part
summarizer_transformers = None

def summarize_paragraph(paragraph: str, sentences_count=2) -> str: # Default to fewer sentences for summarization tests
    """Summarizes a paragraph using Sumy LSA or Transformers."""
    if len(paragraph.split()) < 10: # Check word count instead of char count
        return paragraph # Too short to summarize meaningfully

    if HAS_SHITTONE_OF_RAM:
        # Placeholder for potential future use, skipped in current tests
        global summarizer_transformers
        if summarizer_transformers is None:
            from transformers import pipeline
            summarizer_transformers = pipeline("summarization", model="facebook/bart-large-cnn")
        # Simplified length constraints for testing
        max_len = max(30, len(paragraph.split()) // 2)
        min_len = min(10, max_len // 2)
        try:
            summary_result = summarizer_transformers(paragraph, max_length=max_len, min_length=min_len, truncation=True)
            return summary_result[0]['summary_text']
        except Exception as e:
            print(f"Transformer summarization failed: {e}")
            # Fallback to Sumy if transformer fails
            pass

    # Sumy LSA Summarizer (Default/Fallback)
    try:
        parser = PlaintextParser.from_string(paragraph, Tokenizer("english"))
        stemmer = Stemmer("english")
        summarizer_lsa = LsaSummarizer(stemmer)
        summarizer_lsa.stop_words = get_stop_words("english")
        summary = summarizer_lsa(parser.document, sentences_count)
        return " ".join([str(sentence) for sentence in summary])
    except Exception as e:
        print(f"Sumy summarization failed: {e}")
        return f"Error during summarization. Original length: {len(paragraph)}"


def ExtractText(image_path: str) -> str:
    """Extracts text from an image using Tesseract OCR."""
    try:
        img = Image.open(image_path)
        text = pytesseract.image_to_string(img, lang="eng", config='--psm 6') # PSM 6 assumes a single uniform block of text
        return text.strip()
    except pytesseract.TesseractNotFoundError:
        pytest.skip("Tesseract is not installed or not found in PATH.")
    except FileNotFoundError:
        print(f"Error: Image file not found at {image_path}")
        return ""
    except Exception as e:
        print(f"Error during OCR: {e}")
        return ""

# --- Test Utilities ---
def create_test_image(text, file_prefix="test_img_", width=600, height=100):
    """Creates a simple PNG image with the given text."""
    image = Image.new('RGB', (width, height), color='white')
    draw = ImageDraw.Draw(image)
    try:
        # Try a common font, fallback to default
        font = ImageFont.truetype("arial.ttf", 15)
    except IOError:
        font = ImageFont.load_default()
    draw.text((10, 10), text, fill='black', font=font)

    # Use NamedTemporaryFile to manage cleanup
    temp_file = tempfile.NamedTemporaryFile(prefix=file_prefix, suffix='.png', delete=False)
    image.save(temp_file.name)
    temp_file.close() # Close the file handle but keep the file
    return temp_file.name

@pytest.fixture(scope="module")
def simulated_image_paths():
    """Fixture to create multiple simulated benchmark images for testing."""
    paths = []
    print(f"\nCreating {NUM_SIMULATED_IMAGES} simulated test images...")
    for i in range(NUM_SIMULATED_IMAGES):
        text = random.choice(SIMULATED_BENCHMARK_TEXTS).format(i=i)
        path = create_test_image(text, file_prefix=f"sim_bench_{i}_")
        paths.append(path)
        print(f"  Created: {os.path.basename(path)} with text: '{text[:30]}...'")

    yield paths # Provide the list of paths to the tests

    # Cleanup: Remove the created image files after tests run
    print("\nCleaning up simulated test images...")
    for path in paths:
        try:
            os.remove(path)
            print(f"  Removed: {os.path.basename(path)}")
        except OSError as e:
            print(f"  Error removing {os.path.basename(path)}: {e}")

# Store statistics globally for simplicity in this script
test_stats = {
    "ocr_times": [], "ocr_char_counts": [], "ocr_accuracy_simulated": [],
    "sum_times": [], "sum_compression_ratios": [], "sum_consistency": []
}

# --- Pytest Tests ---

# 1. OCR Tests (ExtractText)
class TestOCRExtraction:

    def test_ocr_basic_extraction(self, simulated_image_paths):
        """Tests if OCR extracts *some* text from the first simulated image."""
        if not simulated_image_paths:
            pytest.skip("No simulated images were created.")

        image_path = simulated_image_paths[0]
        start_time = time.time()
        extracted_text = ExtractText(image_path)
        duration = time.time() - start_time
        test_stats["ocr_times"].append(duration)

        print(f"\n  OCR Basic Test on {os.path.basename(image_path)}:")
        print(f"    Extracted Text: '{extracted_text[:50]}...'")
        print(f"    Execution Time: {duration:.4f}s")

        assert extracted_text is not None, "OCR function should return a string, even if empty."
        assert len(extracted_text) > 5, "Expected some text to be extracted from the image."
        test_stats["ocr_char_counts"].append(len(extracted_text))
        # Simple simulated accuracy: check if common words are present
        expected_words = ["benchmark", "test", "image", "ocr", "case", "input", "text"]
        found_words = [word for word in expected_words if word in extracted_text.lower()]
        sim_acc = len(found_words) > 0
        test_stats["ocr_accuracy_simulated"].append(sim_acc)
        assert sim_acc, f"Expected extracted text to contain some relevant keywords."

    def test_ocr_statistical_performance(self, simulated_image_paths):
        """Runs OCR on all simulated images and calculates average time and basic metrics."""
        if len(simulated_image_paths) < 2:
             pytest.skip("Need at least 2 simulated images for statistical test.")

        print(f"\n  OCR Statistical Test on {len(simulated_image_paths)} images:")
        times = []
        char_counts = []
        accuracies = []

        for image_path in simulated_image_paths:
            start_time = time.time()
            text = ExtractText(image_path)
            duration = time.time() - start_time
            times.append(duration)
            char_counts.append(len(text))
            # Simulate accuracy check (e.g., non-empty and contains expected word)
            expected_words = ["benchmark", "test", "image", "ocr", "case", "input", "text"]
            found_words = [word for word in expected_words if word in text.lower()]
            accuracies.append(len(text) > 0 and len(found_words) > 0)
            print(f"    Processed {os.path.basename(image_path)} ({len(text)} chars) in {duration:.4f}s - AccOK: {accuracies[-1]}")


        avg_time = np.mean(times) if times else 0
        avg_chars = np.mean(char_counts) if char_counts else 0
        avg_accuracy = np.mean(accuracies) * 100 if accuracies else 0

        test_stats["ocr_times"].extend(times) # Add all times
        test_stats["ocr_char_counts"].extend(char_counts)
        test_stats["ocr_accuracy_simulated"].extend(accuracies)

        print(f"    Average OCR Time: {avg_time:.4f}s")
        print(f"    Average Character Count: {avg_chars:.2f}")
        print(f"    Simulated Accuracy Rate: {avg_accuracy:.2f}%")

        assert avg_time < 10, "Average OCR time should be reasonable (<10s)." # Generous limit
        assert avg_chars > 5, "Average extracted text length should be > 5."
        assert avg_accuracy > 50, "Simulated accuracy should be over 50%." # Expect most simple images to work


# 2. Summarization Tests (summarize_paragraph)
class TestSummarization:

    def test_summarize_short_text(self):
        """Tests that very short text is returned as is."""
        short_text = "Too short to summarize."
        summary = summarize_paragraph(short_text)
        print(f"\n  Summarize Short Text Test:")
        print(f"    Input: '{short_text}'")
        print(f"    Output: '{summary}'")
        assert summary == short_text, "Short text should not be summarized."

    def test_summarize_empty_text(self):
        """Tests handling of empty string input."""
        empty_text = ""
        summary = summarize_paragraph(empty_text)
        print(f"\n  Summarize Empty Text Test:")
        print(f"    Input: ''")
        print(f"    Output: '{summary}'")
        assert summary == empty_text, "Empty text should return empty."

    def test_summarization_statistical_performance(self):
        """Runs summarization multiple times on SAMPLE_TEXT for stats."""
        num_trials = 3 # Fewer trials for faster testing
        times = []
        ratios = []
        summaries = []

        print(f"\n  Summarization Statistical Test ({num_trials} trials on SAMPLE_TEXT):")
        original_length = len(SAMPLE_TEXT)

        for i in range(num_trials):
            start_time = time.time()
            summary = summarize_paragraph(SAMPLE_TEXT)
            duration = time.time() - start_time

            times.append(duration)
            summary_length = len(summary)
            ratio = summary_length / original_length if original_length > 0 else 0
            ratios.append(ratio)
            summaries.append(summary)
            print(f"    Trial {i+1}: Time={duration:.4f}s, Len={summary_length}, Ratio={ratio:.2f}")
            print(f"      Summary: '{summary[:60]}...'")


        avg_time = np.mean(times) if times else 0
        avg_ratio = np.mean(ratios) if ratios else 0

        # Basic consistency check: Compare summaries (LSA should be fairly deterministic)
        consistency_scores = []
        if len(summaries) > 1:
            base_summary_words = set(summaries[0].lower().split())
            for i in range(1, len(summaries)):
                current_summary_words = set(summaries[i].lower().split())
                common = len(base_summary_words.intersection(current_summary_words))
                total = len(base_summary_words.union(current_summary_words))
                score = common / total if total > 0 else 1.0 # Consider identical as 100%
                consistency_scores.append(score)

        avg_consistency = np.mean(consistency_scores) * 100 if consistency_scores else 100.0

        test_stats["sum_times"].extend(times)
        test_stats["sum_compression_ratios"].extend([1-r for r in ratios]) # Store as reduction ratio
        test_stats["sum_consistency"].append(avg_consistency)

        print(f"    Average Summarization Time: {avg_time:.4f}s")
        print(f"    Average Compression Ratio: {(1 - avg_ratio)*100:.2f}%") # Output reduction %
        print(f"    Average Consistency (vs first run): {avg_consistency:.2f}%")

        assert avg_time < 5, "Average summarization time should be reasonable (<5s)."
        assert 0 < avg_ratio < 1, "Summarization ratio should be between 0 and 1 (exclusive)."
        assert avg_consistency > 70, "Summaries should be reasonably consistent (>70%)."

# 3. Integration Test
def test_full_pipeline_integration(simulated_image_paths):
    """Tests the full flow: Image -> OCR -> Summarization."""
    if not simulated_image_paths:
        pytest.skip("No simulated images were created.")

    image_path = simulated_image_paths[-1] # Use the last image
    print(f"\n  Full Pipeline Integration Test on {os.path.basename(image_path)}:")
    pipeline_start_time = time.time()

    # 1. OCR
    ocr_start_time = time.time()
    extracted_text = ExtractText(image_path)
    ocr_duration = time.time() - ocr_start_time
    print(f"    1. OCR Result ({ocr_duration:.4f}s): '{extracted_text[:50]}...'")
    assert len(extracted_text) > 5, "OCR step failed to extract sufficient text."

    # 2. Summarization
    sum_start_time = time.time()
    summary = summarize_paragraph(extracted_text)
    sum_duration = time.time() - sum_start_time
    print(f"    2. Summarization Result ({sum_duration:.4f}s): '{summary[:60]}...'")
    assert len(summary) > 0, "Summarization step failed to produce output."
    # Summary should be shorter than extracted text if text was long enough
    if len(extracted_text.split()) >= 10:
         assert len(summary) < len(extracted_text), "Summary should be shorter than extracted text."

    pipeline_duration = time.time() - pipeline_start_time
    print(f"    End-to-End Pipeline Time: {pipeline_duration:.4f}s")
    assert pipeline_duration < 15, "Full pipeline should complete reasonably fast (<15s)."


# --- Statistics Reporting ---
# Use pytest's built-in reporting capabilities and add a final summary.
# We can use a session-scoped fixture or pytest_sessionfinish hook for final stats print.

def pytest_sessionfinish(session):
    """Hook to print summary statistics after all tests are run."""
    print("\n" + "="*70)
    print(colored("STATISTICAL METRICS SUMMARY", "cyan", attrs=["bold"]))
    print("="*70)

    if test_stats["ocr_times"]:
        print(colored("\nOCR Statistics:", "white", attrs=["bold"]))
        print(f"  Average Time:       {np.mean(test_stats['ocr_times']):.4f}s")
        print(f"  Std Dev Time:       {np.std(test_stats['ocr_times']):.4f}s")
        print(f"  Average Char Count: {np.mean(test_stats['ocr_char_counts']):.2f}")
        # Ensure simulated accuracy list contains booleans or 0/1
        sim_acc_numeric = [1 if acc else 0 for acc in test_stats['ocr_accuracy_simulated']]
        print(f"  Simulated Accuracy: {np.mean(sim_acc_numeric)*100:.2f}%")
    else:
        print(colored("\nOCR Statistics: No data collected.", "yellow"))

    if test_stats["sum_times"]:
        print(colored("\nSummarization Statistics:", "white", attrs=["bold"]))
        print(f"  Average Time:           {np.mean(test_stats['sum_times']):.4f}s")
        print(f"  Std Dev Time:           {np.std(test_stats['sum_times']):.4f}s")
        print(f"  Average Compression:    {np.mean(test_stats['sum_compression_ratios'])*100:.2f}%")
        # Assuming sum_consistency stores the avg consistency from the stat test
        print(f"  Average Consistency:    {np.mean(test_stats['sum_consistency']):.2f}%")
    else:
        print(colored("\nSummarization Statistics: No data collected.", "yellow"))

    print("\n" + "="*70)



// ----- server.py -----
import datetime
import json
import os
from Crypto.PublicKey import RSA
import socket
import OCRManager
import cryptManager
import networkManager
import sys
import time
from threading import Thread
import base64
import dotenv

from dbManager import Summary, DbManager
from OCRManager import ExtractText

# from dbManager import DbManager
import pickle
import threading
from typing import Dict
SCOPES = ["https://www.googleapis.com/auth/calendar.readonly"]
CLIENT_SECRETS_FILE = "credentials.json"
API_SERVICE_NAME = "calendar"
API_VERSION = "v3"
PEPPER = b"PEPPER"
id_per_sock = {}
ids_per_summary_id = {}
net_per_sock = {}
lock_per_sock: Dict[socket.socket, threading.Lock] = {}
doc_changes_lock = threading.Lock()
historic_id_per_sock = {}


def handle_key_exchange(
    sock, crypt: cryptManager.CryptManager
) -> networkManager.NetworkManager | None:
    net: networkManager.NetworkManager = networkManager.NetworkManager(sock, crypt, {})
    # print("Public rsa key: ", crypt.get_public_key())
    net.send_message_plain(
        net.build_message("KEY", [crypt.get_public_key()], do_size=True)
    )
    while not net.has_received():
        time.sleep(0.1)
    plain = net.recv_message_plain()
    if plain == b"" or plain == "":
        print("Client disconnected during key exchange")
        return None
    public_key = net.get_message_params(plain.decode())[0]
    crypt.aes_key = base64.b64decode(crypt.decrypt_rsa(base64.b64decode(public_key)))
    net.crypt_manager = crypt
    return net


EVENT_DAY_REMIND = 7


def handle_login(
    db_manager: DbManager, username, password, *, net: networkManager.NetworkManager
) -> bool:
    salt = db_manager.get_salt(username)
    if salt is None:
        net.send_message(net.build_message("LOGIN_FAIL", []))
        return False
    password = net.crypt_manager.hash_pass(password, salt, PEPPER)
    loged = db_manager.authenticate_user(username, password)
    if loged:
        id_per_sock[net.sock] = loged.id
    events = db_manager.get_events(loged.id) if loged else []
    # print("Eve: ", events)
    N_days_from_today = datetime.datetime.now() + datetime.timedelta(
        days=EVENT_DAY_REMIND
    )
    print(N_days_from_today)
    print(events)
    net.send_message(
        net.build_message(
            "LOGIN_SUCCESS" if loged else "LOGIN_FAIL",
            (
                []
                if not loged
                else [
                    base64.b64encode(pickle.dumps(eve)).decode()
                    for eve in filter(
                        lambda x: x["event_date"] <= N_days_from_today,
                        events,
                    )
                ]
            ),
        )
    )
    return False


def handle_register(
    db_manager: DbManager, username, password, *, net: networkManager.NetworkManager
) -> bool:
    salt = net.crypt_manager.generate_random_bytes(16)
    password = net.crypt_manager.hash_pass(password, salt, PEPPER)
    succsses = db_manager.insert_user(username, password, salt)

    net.send_message(
        net.build_message("REGISTER_SUCCESS" if succsses else "REGISTER_FAIL", [])
    )
    if succsses:
        print(f"Registered user {username} with password {password}")
    return False


def handle_summaries(db_manager, *a, net: networkManager.NetworkManager) -> bool:
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    summaries = db_manager.get_all_user_can_access(db_manager.get_id_per_sock(net.sock))
    net.send_message(
        net.build_message(
            "TAKESUMMARIES",
            [base64.b64encode(pickle.dumps(summ)).decode() for summ in summaries],
        )
    )
    return False


def handle_save(
    db_manager, title, summary, font, *, net: networkManager.NetworkManager
) -> bool:
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    print("Saving title: ", title)
    # net.send_message(net.build_message("ERROR",["ASD"]))
    if title == "":
        sid = -1
        for k, v in ids_per_summary_id.items():
            if db_manager.get_id_per_sock(net.sock) in v:
                sid = k
                break
        print(f"Updating, {sid=}")
        db_manager.update_summary(sid, summary, font)

    else:
        db_manager.insert_summary(
            title, summary, db_manager.get_id_per_sock(net.sock), font
        )
    net.send_message(net.build_message("SAVE_SUCCESS", [""]))
    return False


def handle_event(
    db_manager, title, datetime_str, *, net: networkManager.NetworkManager
) -> bool:
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True

    db_manager.insert_event(db_manager.get_id_per_sock(net.sock), title, datetime_str)
    even = db_manager.get_event(db_manager.get_id_per_sock(net.sock), title)
    net.send_message(
        net.build_message(
            "EVENT_SUCCESS", [base64.b64encode(pickle.dumps(even)).decode()]
        )
    )
    return False


def handle_delete_event(
    db_manager, event_id, *, net: networkManager.NetworkManager
) -> bool:
    user_id = db_manager.get_id_per_sock(net.sock)

    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True

    success = db_manager.delete_event(event_id, user_id)

    if success:
        net.send_message(net.build_message("DELETE_SUCCESS", [str(event_id)]))
    else:
        net.send_message(
            net.build_message("ERROR", ["Failed to delete event or event not found"])
        )

    return False


def handle_file(db_manager, path, *, net: networkManager.NetworkManager) -> bool:
    id = db_manager.get_id_per_sock(net.sock)
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    # with open(f"./data/{id}/tmp/{path}", "rb") as jf
    if not os.path.exists(f"./data/{id}/tmp"):
        print("Path does not exist")
        os.makedirs(f"./data/{id}/tmp", exist_ok=False)
    if id not in handlers_per_sock_per_path:
        handlers_per_sock_per_path[id] = {}
    if path in handlers_per_sock_per_path[id]:
        net.send_message(net.build_message("ERROR", ["FILE ALREADY EXISTS(rn)"]))
        return True
    handlers_per_sock_per_path[id][path] = open(f"./data/{id}/tmp/{path}", "wb")
    return False


handlers_per_sock_per_path = {}


def handle_chunk(db_manager, path, data, net: networkManager.NetworkManager) -> bool:
    id = db_manager.get_id_per_sock(net.sock)
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    # resuse handle later.... (matter of adding a global dict of id,
    # that leads to dict of path to file handle then seeing if it exists
    if (
        id not in handlers_per_sock_per_path
        or path not in handlers_per_sock_per_path[id]
    ):
        net.send_message(net.build_message("ERROR", ["NO FILE OPENED"]))
        return True
    f = handlers_per_sock_per_path[id][path]
    f.write(base64.b64decode(data))
    return False


def handle_end(db_manager, path, net: networkManager.NetworkManager) -> bool:
    id = db_manager.get_id_per_sock(net.sock)
    if db_manager.get_is_sock_logged(net.sock) == -1:
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    if (
        id not in handlers_per_sock_per_path
        or path not in handlers_per_sock_per_path[id]
    ):
        net.send_message(net.build_message("ERROR", ["NO FILE OPENED"]))
        return True
    f = handlers_per_sock_per_path[id][path]
    f.close()
    del handlers_per_sock_per_path[id][path]
    return False


def handle_ocr(db_manager, path, net: networkManager.NetworkManager) -> bool:
    # in real life we would have to prevent the RFI LFI
    # but for now we just assume the path is safe
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    if "." in path or ".." in path or path.startswith("/") or path.startswith("\\"):
        net.send_message(net.build_message("ERROR", ["INVALID PATH"]))
        return True
    real_path = f"./data/{db_manager.get_id_per_sock(net.sock)}/tmp/{path}"
    text = ExtractText(real_path)
    net.send_message(net.build_message("FILECONTENT", [text]))
    return False


def handle_summary(db_manager, summary, net: networkManager.NetworkManager) -> bool:
    # id = db_manager.get_id_per_sock(net.sock)
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    summ = OCRManager.summarize_paragraph(
        summary, summary.count(".") - 2 if summary.count(".") > 2 else 1
    )
    net.send_message(net.build_message("SUMMARY", [summ]))
    return False


def build_pdf(content):
    return content


def build_md(content):
    return content


def build_html(content):
    return content


def handle_build_file(db_manager, content, ext):
    file_bytes = content.encode()
    if ext == "pdf":
        file_bytes = build_pdf(file_bytes)
    elif ext == "md":
        file_bytes = build_md(file_bytes)
    elif ext == "html":
        file_bytes = build_html(file_bytes)
    return file_bytes


def handle_export(db_manager, content, ext, net: networkManager.NetworkManager) -> bool:
    # id = db_manager.get_id_per_sock(net.sock)
    if not db_manager.get_is_sock_logged(net.sock):
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    # currently avaliable formats: txt,pdf,md,html
    if ext not in ["txt", "pdf", "md", "html"]:
        net.send_message(net.build_message("ERROR", ["INVALID FORMAT"]))
        return True
    file_bytes = handle_build_file(db_manager, content, ext)
    net.send_message(
        net.build_message("EXPORTED", [base64.b64encode(file_bytes).decode()])
    )
    return False


def handle_get_summary(db_manager, sid, net: networkManager.NetworkManager) -> bool:
    id = db_manager.get_id_per_sock(net.sock)
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    summ: Summary = db_manager.get_summary(sid)
    if summ is None:
        net.send_message(net.build_message("ERROR", ["SUMMARY NOT FOUND"]))
        return True
    with open(summ.path_to_summary, "rb") as f:
        data = f.read()

    net.send_message(
        net.build_message(
            "TAKESUMMARY",
            [base64.b64encode(pickle.dumps({"data": data, "summ": summ})).decode()],
        )
    )

    # scan if id exists, then remove
    for key, value in ids_per_summary_id.items():
        if id in value:
            value.remove(id)
            break
    if summ.id not in ids_per_summary_id:
        ids_per_summary_id[summ.id] = [id]
        spawn_summary_thread(summ, id, net, summ.id)
    else:
        ids_per_summary_id[summ.id].append(id)

    return False


# Add this function to your server.py file
def handle_get_summary_by_link(
    db_manager, link, net: networkManager.NetworkManager
) -> bool:
    # id = db_manager.get_id_per_sock(net.sock)
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    print("Checking db")
    summ: Summary = db_manager.get_summary_by_link(link)
    # print("Sending summary: ", summ)
    if summ is None:
        net.send_message(net.build_message("ERROR", ["SUMMARY NOT FOUND"]))
        return True

    # with open(summ.path_to_summary, "rb") as f:
    #     data = f.read()
    # print("Data: ", data)
    net.send_message(
        # net.build_message("TAKESUMMARY", [base64.b64encode(data).decode()])
        # net.build_message("TAKESUMMARY",[base64.b64encode(pickle.dumps({"data": data, "summ": summ})).decode() ])
        net.build_message("TAKESUMMARYLINK", [str(summ.id)])
    )
    # for key, value in ids_per_summary_id.items():
    #     if id in value:
    #         value.remove(id)
    #         break
    # if id not in ids_per_summary_id:
    #     ids_per_summary_id[summ.id] = []
    #     spawn_summary_thread(summ, id, net, summ.id)
    # ids_per_summary_id[summ.id].append(id)
    #
    return False


def handle_get_events(db_manager, *a, net: networkManager.NetworkManager) -> bool:
    id = db_manager.get_id_per_sock(net.sock)
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True

    events = db_manager.get_events(id)
    print(f"Found {len(events)} events for user {id}")

    net.send_message(
        net.build_message(
            "TAKEEVENTS",
            [base64.b64encode(pickle.dumps(event)).decode() for event in events],
        )
    )
    return False


# def handle_get_document_changes(db_manager) -> Callable:
#     def handle_inner(document_id, net: networkManager.NetworkManager) -> bool:
#         id = db_manager.get_id_per_sock(net.sock)
#         if id == -1:
#             print("NOT logged in")
#             net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
#             return True
#         changes = [
#             {"username": "u1", "position": 1, "content": "hello", "type": "insert"}
#         ]
#         # db_manager.get_document_changes(document_id)
#         net.send_message(
#             net.build_message(
#                 "TAKEDOCUMENTCHANGES",
#                 [json.dumps({"changes": changes})],
#             )
#         )
#         return False
#
#     return handle_inner
#

doc_changes = {}


def handle_update_document(
    db_manager, changes, net: networkManager.NetworkManager
) -> bool:
    global doc_changes
    global documents
    id = db_manager.get_id_per_sock(net.sock)
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    # save into the dict
    # let the thread handle
    document_id = -1
    for k, v in ids_per_summary_id.items():
        if id in v:
            document_id = k
            break
    if document_id == -1:
        # net.send_message(net.build_message("ERROR", ["NO DOCUMENT OPENED"]))
        print("User hasnt oppened a document")
        net.send_message(net.build_message("INFO", ["NO DOCUMENT OPENED"]))
        return False
    # print("Appending to Doc changes: ", doc_changes)
    with doc_changes_lock:
        if document_id not in doc_changes:
            doc_changes[document_id] = {}
        if id not in doc_changes[document_id]:
            doc_changes[document_id][id] = []
        # print(type(changes))
        # print("changes: ", changes)
        # print("changes[changes]: ", changes["changes"])

        if json.loads(changes)["changes"]:
            doc_changes[document_id][id].append(changes)
            # print("Appended: ", changes)
            # print("\n\n\n")
        # else:
        # print("No changes to append? ")
    # print("Appended to Doc changes: ", doc_changes)
    return False


def handle_share_summary(
    db_manager: DbManager, username, net: networkManager.NetworkManager
) -> bool:
    id = db_manager.get_id_per_sock(net.sock)
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    summary_id = -1
    for k, v in ids_per_summary_id.items():
        if id in v:
            summary_id = k
            break
    if summary_id == -1:
        net.send_message(net.build_message("ERROR", ["NO SUMMARY OPENED"]))
        return True
    user_id = db_manager.get_id_by_username(username)
    if user_id == -1:
        net.send_message(net.build_message("ERROR", ["USER NOT FOUND"]))
        return True
    succsess = db_manager.share_summary(summary_id, id, user_id, "edit")
    if not succsess:
        net.send_message(net.build_message("ERROR", ["FAILED TO SHARE"]))
        return True
    net.send_message(net.build_message("SHARE_SUCCESS", []))
    return False


def handle_get_graph(db_manager, *_, net: networkManager.NetworkManager) -> bool:
    id = db_manager.get_id_per_sock(net.sock)
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    sid = -1
    for k, v in ids_per_summary_id.items():
        if id in v:
            sid = k
            break
    if sid == -1:
        net.send_message(net.build_message("ERROR", ["NO SUMMARY OPENED"]))
        return True
    print("Getting graph for: ", sid)
    graph = db_manager.get_graph(sid)
    net.send_message(
        net.build_message("TAKEGRAPH", [base64.b64encode(pickle.dumps(graph)).decode()])
    )
    return False


def handle_saving_events(
    db_manager, jsoned_events, net: networkManager.NetworkManager
) -> bool:
    id = db_manager.get_id_per_sock(net.sock)
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    # print("Saving events: ", jsoned_events)
    events = pickle.loads(base64.b64decode(jsoned_events))  # json.loads(jsoned_events)
    # print(events)
    print(events)
    for event in events:
        db_manager.insert_event(id, event["event_title"], event["event_date"])
    net.send_message(net.build_message("INFO", ["Event successfully added"]))
    return False


def get_historic_list(db_manager, *_, net: networkManager.NetworkManager) -> bool:
    uid = db_manager.get_id_per_sock(net.sock)
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    sid = -1
    for k, v in ids_per_summary_id.items():
        if db_manager.get_id_per_sock(net.sock) in v:
            sid = k
            break
    if sid == -1:
        net.send_message(net.build_message("ERROR", ["NO SUMMARY OPENED"]))
        return True
    # read the directory save/{sid}/ (read sub directorys which are all timestamps)
    dirs = os.listdir(f"save/{sid}/")
    net.send_message(
        net.build_message(
            "HISTORICLIST", [base64.b64encode(pickle.dumps(dirs)).decode()]
        )
    )
    return False


def load_historic_summary(
    db_manager, timestamp, net: networkManager.NetworkManager
) -> bool:
    uid = db_manager.get_id_per_sock(net.sock)
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    sid = -1
    for k, v in ids_per_summary_id.items():
        if db_manager.get_id_per_sock(net.sock) in v:
            sid = k
            break
    if sid == -1:
        net.send_message(net.build_message("ERROR", ["NO SUMMARY OPENED"]))
        return True
    # read the directory save/{sid}/{timestamp}/ (read sub directorys which are all timestamps)
    if not db_manager.can_access(sid, db_manager.get_id_per_sock(net.sock)):
        net.send_message(net.build_message("ERROR", ["NO PERMISSION"]))
        return True

    with open(f"save/{sid}/{timestamp}/summary.md", "rb") as f:
        data = f.read()
    # remove the user from the queues
    for key, value in ids_per_summary_id.items():
        if uid in value:
            value.remove(uid)
            break
    # remove the user from the doc_changes
    summ: Summary = db_manager.get_summary(sid)
    summ.content = data.decode()
    historic_id_per_sock[db_manager.get_id_per_sock(net.sock)] = summ.id
    net.send_message(
        net.build_message(
            "TAKEHIST",
            [base64.b64encode(pickle.dumps({"data": data, "summ": summ})).decode()],
        )
    )
    return False


def handle_historic_graph(
    db_manager, timestamp, net: networkManager.NetworkManager
) -> bool:
    if not db_manager.get_is_sock_logged(net.sock):
        print("NOT logged in")
        net.send_message(net.build_message("ERROR", ["NOT LOGGED IN"]))
        return True
    uid = db_manager.get_id_per_sock(net.sock)
    if uid not in historic_id_per_sock:
        print("NO HISTORIC ID for: ", net.sock)
        print(historic_id_per_sock)
        net.send_message(net.build_message("ERROR", ["NO HISTORIC ID"]))
        return True
    sid = historic_id_per_sock[uid]

    # check premission of user to access the sumamry
    if not db_manager.can_access(sid, db_manager.get_id_per_sock(net.sock)):
        net.send_message(net.build_message("ERROR", ["NO PERMISSION"]))
        return True
    # read the directory save/{sid}/{timestamp}/graph.pkl
    # format as:("%Y%m%d%H%M%S") from YYYY-MM-DD HH:MM:SS
    dt_obj = datetime.datetime.strptime(timestamp, "%Y-%m-%d %H:%M:%S")
    timestampftm = dt_obj.strftime("%Y%m%d%H%M%S")
    with open(f"save/{sid}/{timestampftm}/graph.pkl", "rb") as f:
        data = f.read()
    dumped_data = base64.b64encode(data).decode()
    net.send_message(net.build_message("TAKEGRAPH", [dumped_data]))
    return False


def thread_main(sock, addr, crypt):
    net: networkManager.NetworkManager | None = handle_key_exchange(sock, crypt)
    if net is None:
        print("Client disconnected during key exchange")
        return
    net.set_lock(threading.Lock())
    print("Finished key exchange for: ", addr)
    db_manager = DbManager()
    db_manager.id_per_sock = id_per_sock
    # with open("db_config.json", "rb") as f:
    #     db_manager.connect_to_db(json.loads(f.read()))
    if USE_MYSQL:
        db_manager.connect_to_db(
            {
                "host": os.getenv("DB_HOST"),
                "user": os.getenv("DB_USERNAME"),
                "password": (os.getenv("DB_PASSWORD")),
                "database": os.getenv("DB_NAME"),
                "port": os.getenv("DB_PORT"),
            }
        )
    else:
        db_manager.connect_to_sqlite({"db_type": "sqlite", "database": "dbconved.db"})
    net.add_handler("EXIT", lambda: True)
    net.add_handler("LOGIN", handle_login)
    net.add_handler("REGISTER", handle_register)
    net.add_handler("GETSUMMARIES", handle_summaries)
    net.add_handler("SAVE", handle_save)
    net.add_handler("ADDEVENT", handle_event)
    net.add_handler("FILE", handle_file)
    net.add_handler("CHUNK", handle_chunk)
    net.add_handler("END", handle_end)
    net.add_handler("GETFILECONTENT", handle_ocr)
    net.add_handler("SUMMARIZE", handle_summary)
    net.add_handler("EXPORT", handle_export)
    net.add_handler("GETSUMMARY", handle_get_summary)
    net.add_handler("GETEVENTS", handle_get_events)
    net.add_handler("DELETEEVENT", handle_delete_event)
    net.add_handler("GETSUMMARYLINK", handle_get_summary_by_link)
    # net.add_handler("GET_DOCUMENT_CHANGES", handle_get_document_changes)
    net.add_handler("UPDATEDOC", handle_update_document)
    net.add_handler("SHARESUMMARY", handle_share_summary)
    net.add_handler("GETGRAPH", handle_get_graph)
    net.add_handler("SAVE_EVENTS", handle_saving_events)
    net.add_handler("GETHISTORICLIST", get_historic_list)
    net.add_handler("LOADHISTORIC", load_historic_summary)
    net.add_handler("HISTORICGRAPH", handle_historic_graph)
    net_per_sock[sock] = net
    sock.settimeout(0.5)
    while True:
        # with lock_per_sock[sock]:
        try:
            exited = net.recv_handle_server(db_manager)  # net.wait_recv()
            if exited:
                print("Exiting thread")
                return

            time.sleep(1)
        except socket.timeout:
            print("Timeout lock outght to free")
            pass


def update_insert_coordinates(change_data, start, offset):
    """Update coordinates for INSERT operations"""
    start_pos, end_pos = change_data["cord"]

    # For inserts, shift positions at or after the insertion point
    if start_pos >= start:
        change_data["cord"][0] += offset
    if end_pos >= start:
        change_data["cord"][1] += offset


def update_delete_coordinates(change_data, start, end, offset):
    """Update coordinates for DELETE operations"""
    start_pos, end_pos = change_data["cord"]

    # For deletes, handle positions based on their relation to deleted segment
    if start_pos >= end:
        # Position is after the deleted segment, shift backward
        change_data["cord"][0] += offset
    elif start_pos > start:
        # Position is within deleted segment, collapse to start
        change_data["cord"][0] = start

    if end_pos >= end:
        # End position is after deleted segment
        change_data["cord"][1] += offset
    elif end_pos > start:
        # End position is within deleted segment
        change_data["cord"][1] = start


def update_update_coordinates(change_data, end, offset):
    """Update coordinates for UPDATE operations"""
    start_pos, end_pos = change_data["cord"]

    # For updates, shift positions after the update point by offset
    if start_pos >= end:
        change_data["cord"][0] += offset
    if end_pos >= end:
        change_data["cord"][1] += offset


def update_coordinates(sid, change_id, change_type, start, end, offset):
    """
    Update coordinates of other pending changes based on the applied change

    Parameters:
    - sid: Summary ID
    - change_id: ID of the current change being processed
    - change_type: Type of change (INSERT, DELETE, UPDATE)
    - start: Start position of the change
    - end: End position of the change
    - offset: The amount by which positions shift (positive or negative)
    """
    # Skip if there are no changes for this summary
    if sid not in doc_changes:
        return

    # Process each pending change in the document
    for other_id, other_changes in doc_changes[sid].items():
        # Skip the current change being applied
        if other_id == change_id:
            continue

        for other_change in other_changes:
            if change_type == "INSERT":
                update_insert_coordinates(other_change, start, offset)
            elif change_type == "DELETE":
                update_delete_coordinates(other_change, start, end, offset)
            elif change_type == "UPDATE":
                update_update_coordinates(other_change, end, offset)


def apply_change(doc_content, change):
    """Apply a single change to the document content"""
    start, end = change["cord"]
    change_type = change["type"]
    content = change.get("cont", "")

    if change_type == "INSERT":
        # Insert content at the specified position
        new_content = doc_content[:start] + content + doc_content[start:]
        offset = len(content)
    elif change_type == "DELETE":
        # Remove content between start and end
        new_content = doc_content[:start] + doc_content[end:]
        offset = start - end
    else:  # UPDATE
        # Replace content between start and end
        new_content = doc_content[:start] + content + doc_content[end:]
        offset = len(content) - (end - start)

    return new_content, offset, change_type, start, end


def process_changes(sid, doc_content):
    """Process all pending changes for a summary"""
    changes_processed = False

    # Process each batch of changes (one change_id at a time)
    for change_id, changes in list(doc_changes[sid].items()):
        for change_data in changes:
            # Parse the change data
            change_obj = json.loads(change_data)["changes"]
            if not change_obj:
                print("Empty change object, skipping")
                continue

            # Process the first change in the batch
            change = change_obj[0]
            print(f"Applying change: {change}")

            # Apply the change
            doc_content, offset, change_type, start, end = apply_change(
                doc_content, change
            )

            # Update coordinates of all other pending changes
            update_coordinates(sid, change_id, change_type, start, end, offset)

        # Remove processed changes
        del doc_changes[sid][change_id]
        changes_processed = True

    return doc_content, changes_processed


def send_updates_to_users(sid, doc_content):
    """Send updated content to all connected users"""
    connected_users = ids_per_summary_id[sid]
    print(f"Sending updates to {len(connected_users)} connected users")

    for user_id in connected_users:
        try:
            # Get the socket associated with this user
            sock_per_id = {v: k for k, v in id_per_sock.items()}
            user_socket = sock_per_id[user_id]

            # Send the updated content
            net = net_per_sock[user_socket]
            update_message = net.build_message(
                "TAKEUPDATE",
                [
                    base64.b64encode(
                        json.dumps({"doc_content": doc_content}).encode()
                    ).decode()
                ],
            )
            net.send_message(update_message)
            print(f"Update sent to user {user_id}")
        except Exception as e:
            print(f"Error sending update to user {user_id}: {e}")


def summary_thread(sid, db_manager):
    """
    Main thread function that processes document changes for a given summary ID
    """
    doc_content = ""
    try:
        sid = int(sid)
        print(f"Starting summary thread for: {sid}")

        # Initialize document content from database
        with doc_changes_lock:
            doc = db_manager.get_summary(sid)
            doc_content = doc.content if doc and doc.content else ""

        print("Entering the processing loop")

        # Continue as long as clients are connected to this summary
        while ids_per_summary_id[sid]:
            changes_found = False
            with doc_changes_lock:
                if sid in doc_changes and doc_changes[sid]:
                    changes_found = True
            if not changes_found:
                time.sleep(0.5)
                continue
            with doc_changes_lock:
                if sid not in doc_changes or not doc_changes[sid]:
                    continue
                doc_content, changes_processed = process_changes(sid, doc_content)
                if changes_processed:
                    print("Changes processed successfully")
            if changes_processed:
                send_updates_to_users(sid, doc_content)
                print("All users updated successfully")
        return

    except Exception as e:
        print(f"Error in summary thread: {e}")
        import traceback

        traceback.print_exc()

        # Attempt to restart the thread on error
        summary_thread(sid, db_manager)

    finally:
        print(f"Summary thread terminated for summary ID: {sid}")
        # Save final document state before exiting
        try:
            db_manager.save_summary(sid, doc_content)
            print(f"Final document state saved for summary {sid}")
        except Exception as e:
            print(f"Failed to save final state: {e}")


def spawn_summary_thread(summ, id, net, sid):
    global threads
    db_manager = DbManager()
    db_manager.connect_to_db(
        {
            "host": os.getenv("DB_HOST"),
            "user": os.getenv("DB_USERNAME"),
            "password": (os.getenv("DB_PASSWORD")),
            "database": os.getenv("DB_NAME"),
            "port": os.getenv("DB_PORT"),
        }
    )
    thread = Thread(target=summary_thread, args=(sid, db_manager))
    thread.start()
    # thread.join()
    threads.append(thread)


def main(sock, crypt, t1):
    sock.listen(5)
    global threads
    threads = []
    while True:
        t2 = time.time()
        print("Starting up time: ", t2 - t1)
        print("Listening....")
        client_sock, addr = sock.accept()
        print(f"Connection from {addr}")
        lock_per_sock[client_sock] = threading.Lock()
        crypt = cryptManager.CryptManager(rsa_key)
        thread = Thread(target=thread_main, args=(client_sock, addr, crypt))
        thread.start()
        threads.append(thread)
    for th in threads:
        th.join()


USE_MYSQL = False
if __name__ == "__main__":
    print("Done importing")
    t1 = time.time()
    # read a .env file
    dotenv.load_dotenv()
    if USE_MYSQL:
        print("Using mysql")
    else:
        print("Using sqlite")
    if USE_MYSQL and not all(
        [
            os.getenv("DB_PASSWORD"),
            os.getenv("DB_USERNAME"),
            os.getenv("DB_HOST"),
            os.getenv("DB_PORT"),
            os.getenv("DB_NAME"),
        ]
    ):
        print("make sure all env variables are defined.")
        exit()
    elif not USE_MYSQL and not os.path.isfile("dbconved.db"):
        print("Create the db")
        exit()

    port = int(sys.argv[1]) if len(sys.argv) > 1 else 12345
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(("0.0.0.0", port))

    if os.path.isfile("private.pem"):
        print("Using existing key")
        rsa_key = RSA.import_key(open("private.pem", "rb").read())
    else:
        rsa_key = RSA.generate(2048)
        with open("private.pem", "wb") as f:
            f.write(rsa_key.export_key())
    # rsa_key = (
    #     RSA.import_key(open("private.pem", "rb").read())
    #     if os.path.isfile("private.pem")
    #     else RSA.generate(2048)
    # )

    main(sock, rsa_key, t1)


// ----- SummaryCarousell.py -----
import wx
from dataclasses import dataclass
from datetime import datetime
class SummaryCarousel(wx.Dialog):
    def __init__(self, summaries, net, parent):
        super().__init__(None, title="Summaries Carousel", size=(800, 600))
        self.summaries = summaries
        self.parent = parent
        self.net = net
        self.current_index = 0 if summaries else -1

        # Main layout
        panel = wx.Panel(self)
        main_sizer = wx.BoxSizer(wx.VERTICAL)

        # Title
        title = wx.StaticText(panel, label="Summary Carousel")
        title.SetFont(
            wx.Font(14, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD)
        )
        main_sizer.Add(title, flag=wx.ALIGN_CENTER | wx.TOP | wx.BOTTOM, border=10)

        # Carousel container
        carousel_panel = wx.Panel(panel)
        carousel_panel.SetBackgroundColour(wx.Colour(245, 245, 245))
        carousel_sizer = wx.BoxSizer(wx.VERTICAL)

        # Navigation and counter
        nav_sizer = wx.BoxSizer(wx.HORIZONTAL)

        self.prev_btn = wx.Button(carousel_panel, label="", size=(40, 30))
        self.counter_text = wx.StaticText(carousel_panel, label="")
        self.next_btn = wx.Button(carousel_panel, label="", size=(40, 30))

        nav_sizer.Add(self.prev_btn, flag=wx.ALL, border=5)
        nav_sizer.Add(
            self.counter_text,
            proportion=1,
            flag=wx.ALIGN_CENTER_VERTICAL | wx.ALL,
            border=5,
        )
        nav_sizer.Add(self.next_btn, flag=wx.ALL, border=5)

        carousel_sizer.Add(nav_sizer, flag=wx.EXPAND | wx.ALL, border=5)

        # Summary details
        self.summary_panel = wx.Panel(carousel_panel)
        summary_sizer = wx.BoxSizer(wx.VERTICAL)

        # Info section
        info_sizer = wx.BoxSizer(wx.HORIZONTAL)

        # Left column - Summary metadata
        meta_sizer = wx.BoxSizer(wx.VERTICAL)
        self.share_link = wx.StaticText(
            self.summary_panel, label="", style=wx.ST_ELLIPSIZE_END
        )
        self.share_link.SetFont(
            wx.Font(12, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD)
        )
        self.owner_id = wx.StaticText(self.summary_panel, label="")
        self.create_time = wx.StaticText(self.summary_panel, label="")

        meta_sizer.Add(self.share_link, flag=wx.EXPAND | wx.BOTTOM, border=5)
        meta_sizer.Add(self.owner_id, flag=wx.EXPAND | wx.BOTTOM, border=3)
        meta_sizer.Add(self.create_time, flag=wx.EXPAND | wx.BOTTOM, border=3)

        info_sizer.Add(meta_sizer, proportion=1, flag=wx.EXPAND | wx.RIGHT, border=10)

        # Add info section to summary sizer
        summary_sizer.Add(info_sizer, flag=wx.EXPAND | wx.ALL, border=10)

        # Content preview section
        preview_label = wx.StaticText(self.summary_panel, label="Content Preview:")
        preview_label.SetFont(
            wx.Font(11, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD)
        )
        summary_sizer.Add(preview_label, flag=wx.LEFT | wx.RIGHT | wx.TOP, border=10)

        self.content_preview = wx.TextCtrl(
            self.summary_panel,
            style=wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_AUTO_URL,
            size=(-1, 150),
        )
        summary_sizer.Add(
            self.content_preview, proportion=1, flag=wx.EXPAND | wx.ALL, border=10
        )

        self.summary_panel.SetSizer(summary_sizer)
        carousel_sizer.Add(
            self.summary_panel, proportion=1, flag=wx.EXPAND | wx.ALL, border=5
        )

        carousel_panel.SetSizer(carousel_sizer)
        main_sizer.Add(carousel_panel, proportion=1, flag=wx.EXPAND | wx.ALL, border=10)

        # Bottom buttons
        btn_sizer = wx.BoxSizer(wx.HORIZONTAL)
        open_button = wx.Button(panel, label="Open Selected Summary")
        close_button = wx.Button(panel, label="Close")

        btn_sizer.Add(open_button, flag=wx.ALL, border=5)
        btn_sizer.Add(close_button, flag=wx.ALL, border=5)

        main_sizer.Add(btn_sizer, flag=wx.ALIGN_CENTER | wx.BOTTOM, border=10)

        panel.SetSizer(main_sizer)

        # Bind events
        self.prev_btn.Bind(wx.EVT_BUTTON, self.on_prev)
        self.next_btn.Bind(wx.EVT_BUTTON, self.on_next)
        open_button.Bind(wx.EVT_BUTTON, self.on_open_summary)
        close_button.Bind(wx.EVT_BUTTON, self.on_close)

        # Initialize the carousel display
        self.update_display()

    def update_display(self):
        if not self.summaries:
            self.summary_panel.Hide()
            self.prev_btn.Disable()
            self.next_btn.Disable()
            self.counter_text.SetLabel("No summaries available")
            return

        self.summary_panel.Show()

        # Update counter
        self.counter_text.SetLabel(f"{self.current_index + 1} of {len(self.summaries)}")

        # Enable/disable navigation buttons
        self.prev_btn.Enable(self.current_index > 0)
        self.next_btn.Enable(self.current_index < len(self.summaries) - 1)

        # Update summary details
        current_summary = self.summaries[self.current_index]
        self.share_link.SetLabel(f"{current_summary.shareLink}")
        self.owner_id.SetLabel(f"By User: {current_summary.ownerId}")
        self.create_time.SetLabel(
            f"Created on: {current_summary.createTime.strftime('%Y-%m-%d %H:%M:%S')}"
        )

        # Update content preview - trying to access content if available
        try:
            # Get a preview of the content (first 300 chars)
            content_text = (
                str(current_summary.content)[:300]
                if hasattr(current_summary, "content")
                else "Content preview not available"
            )
            if len(content_text) == 300:
                content_text += "..."
            self.content_preview.SetValue(content_text)
        except (AttributeError, TypeError):
            self.content_preview.SetValue("Content preview not available")

        # Force layout update
        self.Layout()

    def on_prev(self, event):
        if self.current_index > 0:
            self.current_index -= 1
            self.update_display()

    def on_next(self, event):
        if self.current_index < len(self.summaries) - 1:
            self.current_index += 1
            self.update_display()

    def on_open_summary(self, event):
        if not self.summaries:
            wx.MessageBox(
                "No summaries available to open.",
                "No Summaries",
                wx.OK | wx.ICON_WARNING,
            )
            return

        selected_summary = self.summaries[self.current_index]

        wx.MessageBox(
            f"Opening summary:\n\n"
            f"Name: {selected_summary.shareLink}\n"
            f"Path: {selected_summary.path_to_summary if hasattr(selected_summary, 'path_to_summary') else 'N/A'}",
            "Open Summary",
            wx.OK | wx.ICON_INFORMATION,
        )

        # Send the network message to get the summary
        self.net.send_message(
            self.net.build_message("GETSUMMARY", [str(selected_summary.id)])
        )

    def on_close(self, event):
        self.Close()

@dataclass
class MockSummary:
    id: int
    shareLink: str
    ownerId: str
    createTime: datetime
    content: str = "This is a sample summary content with enough text to demonstrate the content preview functionality. It should be long enough to test the truncation feature which happens at 300 characters. This mock content is designed to simulate a real summary that would appear in the carousel, allowing us to see how the text wrapping and display would work in a real world scenario."
    path_to_summary: str = "/path/to/summary"


class MockNetwork:
    def send_message(self, message):
        print(f"Network message sent: {message}")
    
    def build_message(self, command, params):
        return f"{command}: {', '.join(params)}"
if __name__ == "__main__":
    app = wx.App()
    
    # Create mock data
    mock_summaries = [
        MockSummary(
            id=1,
            shareLink="Summary 1: Project Overview",
            ownerId="user123",
            createTime=datetime(2025, 5, 1, 12, 30, 45)
        ),
        MockSummary(
            id=2,
            shareLink="Summary 2: Research Findings",
            ownerId="user456",
            createTime=datetime(2025, 5, 2, 9, 15, 22),
            content="Different content for the second summary. This demonstrates how the carousel can switch between different summary objects and display their unique content."
        ),
        MockSummary(
            id=3,
            shareLink="Summary 3: Action Items",
            ownerId="user789",
            createTime=datetime(2025, 5, 3, 14, 45, 0),
            content="A third summary with distinct content to show carousel navigation. Users can navigate between summaries using the arrow buttons."
        )
    ]
    
    # Create and show the dialog
    mock_network = MockNetwork()
    dialog = SummaryCarousel(mock_summaries, mock_network, None)
    dialog.ShowModal()
    dialog.Destroy()
    
    app.MainLoop()


